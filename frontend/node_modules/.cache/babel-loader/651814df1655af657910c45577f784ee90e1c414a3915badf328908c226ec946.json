{"ast":null,"code":"import { Room as e, RoomEvent as t, ConnectionState as n, Track as o, createLocalAudioTrack as s } from \"livekit-client\";\nfunction a() {\n  return a = Object.assign ? Object.assign.bind() : function (e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var n = arguments[t];\n      for (var o in n) ({}).hasOwnProperty.call(n, o) && (e[o] = n[o]);\n    }\n    return e;\n  }, a.apply(null, arguments);\n}\nconst i = new Uint8Array(0);\nclass r {\n  static getFullOptions(e) {\n    return a({\n      clientTools: {},\n      onConnect: () => {},\n      onDebug: () => {},\n      onDisconnect: () => {},\n      onError: () => {},\n      onMessage: () => {},\n      onAudio: () => {},\n      onModeChange: () => {},\n      onStatusChange: () => {},\n      onCanSendFeedbackChange: () => {},\n      onInterruption: () => {}\n    }, e);\n  }\n  constructor(e, t) {\n    var n = this;\n    this.options = void 0, this.connection = void 0, this.lastInterruptTimestamp = 0, this.mode = \"listening\", this.status = \"connecting\", this.volume = 1, this.currentEventId = 1, this.lastFeedbackEventId = 0, this.canSendFeedback = !1, this.endSessionWithDetails = async function (e) {\n      \"connected\" !== n.status && \"connecting\" !== n.status || (n.updateStatus(\"disconnecting\"), await n.handleEndSession(), n.updateStatus(\"disconnected\"), n.options.onDisconnect && n.options.onDisconnect(e));\n    }, this.onMessage = async function (e) {\n      switch (e.type) {\n        case \"interruption\":\n          return void n.handleInterruption(e);\n        case \"agent_response\":\n          return void n.handleAgentResponse(e);\n        case \"user_transcript\":\n          return void n.handleUserTranscript(e);\n        case \"internal_tentative_agent_response\":\n          return void n.handleTentativeAgentResponse(e);\n        case \"client_tool_call\":\n          try {\n            await n.handleClientToolCall(e);\n          } catch (t) {\n            n.onError(`Unexpected error in client tool call handling: ${t instanceof Error ? t.message : String(t)}`, {\n              clientToolName: e.client_tool_call.tool_name,\n              toolCallId: e.client_tool_call.tool_call_id\n            });\n          }\n          return;\n        case \"audio\":\n          return void n.handleAudio(e);\n        case \"vad_score\":\n          return void n.handleVadScore(e);\n        case \"ping\":\n          return void n.connection.sendMessage({\n            type: \"pong\",\n            event_id: e.ping_event.event_id\n          });\n        case \"mcp_tool_call\":\n          return void n.handleMCPToolCall(e);\n        case \"mcp_connection_status\":\n          return void n.handleMCPConnectionStatus(e);\n        case \"agent_tool_request\":\n          return void n.handleAgentToolRequest(e);\n        case \"agent_tool_response\":\n          return void n.handleAgentToolResponse(e);\n        case \"conversation_initiation_metadata\":\n          return void n.handleConversationMetadata(e);\n        case \"asr_initiation_metadata\":\n          return void n.handleAsrInitiationMetadata(e);\n        case \"agent_chat_response_part\":\n          return void n.handleAgentChatResponsePart(e);\n        case \"error\":\n          return void n.handleErrorEvent(e);\n        default:\n          return void (n.options.onDebug && n.options.onDebug(e));\n      }\n    }, this.setVolume = ({\n      volume: e\n    }) => {\n      this.volume = e;\n    }, this.options = e, this.connection = t, this.options.onConnect && this.options.onConnect({\n      conversationId: t.conversationId\n    }), this.connection.onMessage(this.onMessage), this.connection.onDisconnect(this.endSessionWithDetails), this.connection.onModeChange(e => this.updateMode(e)), this.updateStatus(\"connected\");\n  }\n  endSession() {\n    return this.endSessionWithDetails({\n      reason: \"user\"\n    });\n  }\n  async handleEndSession() {\n    this.connection.close();\n  }\n  updateMode(e) {\n    e !== this.mode && (this.mode = e, this.options.onModeChange && this.options.onModeChange({\n      mode: e\n    }));\n  }\n  updateStatus(e) {\n    e !== this.status && (this.status = e, this.options.onStatusChange && this.options.onStatusChange({\n      status: e\n    }));\n  }\n  updateCanSendFeedback() {\n    const e = this.currentEventId !== this.lastFeedbackEventId;\n    this.canSendFeedback !== e && (this.canSendFeedback = e, this.options.onCanSendFeedbackChange && this.options.onCanSendFeedbackChange({\n      canSendFeedback: e\n    }));\n  }\n  handleInterruption(e) {\n    e.interruption_event && (this.lastInterruptTimestamp = e.interruption_event.event_id, this.options.onInterruption && this.options.onInterruption({\n      event_id: e.interruption_event.event_id\n    }));\n  }\n  handleAgentResponse(e) {\n    this.options.onMessage && this.options.onMessage({\n      source: \"ai\",\n      role: \"agent\",\n      message: e.agent_response_event.agent_response\n    });\n  }\n  handleUserTranscript(e) {\n    this.options.onMessage && this.options.onMessage({\n      source: \"user\",\n      role: \"user\",\n      message: e.user_transcription_event.user_transcript\n    });\n  }\n  handleTentativeAgentResponse(e) {\n    this.options.onDebug && this.options.onDebug({\n      type: \"tentative_agent_response\",\n      response: e.tentative_agent_response_internal_event.tentative_agent_response\n    });\n  }\n  handleVadScore(e) {\n    this.options.onVadScore && this.options.onVadScore({\n      vadScore: e.vad_score_event.vad_score\n    });\n  }\n  async handleClientToolCall(e) {\n    if (Object.prototype.hasOwnProperty.call(this.options.clientTools, e.client_tool_call.tool_name)) try {\n      var t;\n      const n = null != (t = await this.options.clientTools[e.client_tool_call.tool_name](e.client_tool_call.parameters)) ? t : \"Client tool execution successful.\",\n        o = \"object\" == typeof n ? JSON.stringify(n) : String(n);\n      this.connection.sendMessage({\n        type: \"client_tool_result\",\n        tool_call_id: e.client_tool_call.tool_call_id,\n        result: o,\n        is_error: !1\n      });\n    } catch (t) {\n      this.onError(`Client tool execution failed with following error: ${null == t ? void 0 : t.message}`, {\n        clientToolName: e.client_tool_call.tool_name\n      }), this.connection.sendMessage({\n        type: \"client_tool_result\",\n        tool_call_id: e.client_tool_call.tool_call_id,\n        result: `Client tool execution failed: ${null == t ? void 0 : t.message}`,\n        is_error: !0\n      });\n    } else {\n      if (this.options.onUnhandledClientToolCall) return void this.options.onUnhandledClientToolCall(e.client_tool_call);\n      this.onError(`Client tool with name ${e.client_tool_call.tool_name} is not defined on client`, {\n        clientToolName: e.client_tool_call.tool_name\n      }), this.connection.sendMessage({\n        type: \"client_tool_result\",\n        tool_call_id: e.client_tool_call.tool_call_id,\n        result: `Client tool with name ${e.client_tool_call.tool_name} is not defined on client`,\n        is_error: !0\n      });\n    }\n  }\n  handleAudio(e) {}\n  handleMCPToolCall(e) {\n    this.options.onMCPToolCall && this.options.onMCPToolCall(e.mcp_tool_call);\n  }\n  handleMCPConnectionStatus(e) {\n    this.options.onMCPConnectionStatus && this.options.onMCPConnectionStatus(e.mcp_connection_status);\n  }\n  handleAgentToolRequest(e) {\n    this.options.onAgentToolRequest && this.options.onAgentToolRequest(e.agent_tool_request);\n  }\n  handleAgentToolResponse(e) {\n    \"end_call\" === e.agent_tool_response.tool_name && this.endSessionWithDetails({\n      reason: \"agent\",\n      context: new CloseEvent(\"end_call\", {\n        reason: \"Agent ended the call\"\n      })\n    }), this.options.onAgentToolResponse && this.options.onAgentToolResponse(e.agent_tool_response);\n  }\n  handleConversationMetadata(e) {\n    this.options.onConversationMetadata && this.options.onConversationMetadata(e.conversation_initiation_metadata_event);\n  }\n  handleAsrInitiationMetadata(e) {\n    this.options.onAsrInitiationMetadata && this.options.onAsrInitiationMetadata(e.asr_initiation_metadata_event);\n  }\n  handleAgentChatResponsePart(e) {\n    this.options.onAgentChatResponsePart && this.options.onAgentChatResponsePart(e.text_response_part);\n  }\n  handleErrorEvent(e) {\n    const t = e.error_event.error_type,\n      n = e.error_event.message || e.error_event.reason || \"Unknown error\";\n    \"max_duration_exceeded\" !== t ? this.onError(`Server error: ${n}`, {\n      errorType: t,\n      code: e.error_event.code,\n      debugMessage: e.error_event.debug_message,\n      details: e.error_event.details\n    }) : this.endSessionWithDetails({\n      reason: \"error\",\n      message: n,\n      context: new Event(\"max_duration_exceeded\")\n    });\n  }\n  onError(e, t) {\n    console.error(e, t), this.options.onError && this.options.onError(e, t);\n  }\n  getId() {\n    return this.connection.conversationId;\n  }\n  isOpen() {\n    return \"connected\" === this.status;\n  }\n  setMicMuted(e) {\n    this.connection.setMicMuted(e);\n  }\n  getInputByteFrequencyData() {\n    return i;\n  }\n  getOutputByteFrequencyData() {\n    return i;\n  }\n  getInputVolume() {\n    return 0;\n  }\n  getOutputVolume() {\n    return 0;\n  }\n  sendFeedback(e) {\n    this.canSendFeedback ? (this.connection.sendMessage({\n      type: \"feedback\",\n      score: e ? \"like\" : \"dislike\",\n      event_id: this.currentEventId\n    }), this.lastFeedbackEventId = this.currentEventId, this.updateCanSendFeedback()) : console.warn(0 === this.lastFeedbackEventId ? \"Cannot send feedback: the conversation has not started yet.\" : \"Cannot send feedback: feedback has already been sent for the current response.\");\n  }\n  sendContextualUpdate(e) {\n    this.connection.sendMessage({\n      type: \"contextual_update\",\n      text: e\n    });\n  }\n  sendUserMessage(e) {\n    this.connection.sendMessage({\n      type: \"user_message\",\n      text: e\n    });\n  }\n  sendUserActivity() {\n    this.connection.sendMessage({\n      type: \"user_activity\"\n    });\n  }\n  sendMCPToolApprovalResult(e, t) {\n    this.connection.sendMessage({\n      type: \"mcp_tool_approval_result\",\n      tool_call_id: e,\n      is_approved: t\n    });\n  }\n}\nclass c {\n  constructor(e = {}) {\n    this.queue = [], this.disconnectionDetails = null, this.onDisconnectCallback = null, this.onMessageCallback = null, this.onModeChangeCallback = null, this.onDebug = void 0, this.onDebug = e.onDebug;\n  }\n  debug(e) {\n    this.onDebug && this.onDebug(e);\n  }\n  onMessage(e) {\n    this.onMessageCallback = e;\n    const t = this.queue;\n    this.queue = [], t.length > 0 && queueMicrotask(() => {\n      t.forEach(e);\n    });\n  }\n  onDisconnect(e) {\n    this.onDisconnectCallback = e;\n    const t = this.disconnectionDetails;\n    t && queueMicrotask(() => {\n      e(t);\n    });\n  }\n  onModeChange(e) {\n    this.onModeChangeCallback = e;\n  }\n  updateMode(e) {\n    var t;\n    null == (t = this.onModeChangeCallback) || t.call(this, e);\n  }\n  disconnect(e) {\n    var t;\n    this.disconnectionDetails || (this.disconnectionDetails = e, null == (t = this.onDisconnectCallback) || t.call(this, e));\n  }\n  handleMessage(e) {\n    this.onMessageCallback ? this.onMessageCallback(e) : this.queue.push(e);\n  }\n}\nfunction l(e) {\n  const [t, n] = e.split(\"_\");\n  if (![\"pcm\", \"ulaw\"].includes(t)) throw new Error(`Invalid format: ${e}`);\n  const o = Number.parseInt(n);\n  if (Number.isNaN(o)) throw new Error(`Invalid sample rate: ${n}`);\n  return {\n    format: t,\n    sampleRate: o\n  };\n}\nconst u = \"0.12.0\";\nfunction d(e) {\n  return !!e.type;\n}\nconst h = \"conversation_initiation_client_data\";\nfunction p(e) {\n  var t;\n  const n = {\n    type: h\n  };\n  var o, s, a, i, r;\n  return e.overrides && (n.conversation_config_override = {\n    agent: {\n      prompt: null == (o = e.overrides.agent) ? void 0 : o.prompt,\n      first_message: null == (s = e.overrides.agent) ? void 0 : s.firstMessage,\n      language: null == (a = e.overrides.agent) ? void 0 : a.language\n    },\n    tts: {\n      voice_id: null == (i = e.overrides.tts) ? void 0 : i.voiceId\n    },\n    conversation: {\n      text_only: null == (r = e.overrides.conversation) ? void 0 : r.textOnly\n    }\n  }), e.customLlmExtraBody && (n.custom_llm_extra_body = e.customLlmExtraBody), e.dynamicVariables && (n.dynamic_variables = e.dynamicVariables), e.userId && (n.user_id = e.userId), null != (t = e.overrides) && t.client && (n.source_info = {\n    source: e.overrides.client.source,\n    version: e.overrides.client.version\n  }), n;\n}\nclass m extends c {\n  constructor(e, t, n, o) {\n    super(), this.socket = void 0, this.conversationId = void 0, this.inputFormat = void 0, this.outputFormat = void 0, this.socket = e, this.conversationId = t, this.inputFormat = n, this.outputFormat = o, this.socket.addEventListener(\"error\", e => {\n      setTimeout(() => this.disconnect({\n        reason: \"error\",\n        message: \"The connection was closed due to a socket error.\",\n        context: e\n      }), 0);\n    }), this.socket.addEventListener(\"close\", e => {\n      this.disconnect(1e3 === e.code ? {\n        reason: \"agent\",\n        context: e\n      } : {\n        reason: \"error\",\n        message: e.reason || \"The connection was closed by the server.\",\n        context: e\n      });\n    }), this.socket.addEventListener(\"message\", e => {\n      try {\n        const t = JSON.parse(e.data);\n        if (!d(t)) return void this.debug({\n          type: \"invalid_event\",\n          message: \"Received invalid socket event\",\n          data: e.data\n        });\n        this.handleMessage(t);\n      } catch (t) {\n        this.debug({\n          type: \"parsing_error\",\n          message: \"Failed to parse socket message\",\n          error: t instanceof Error ? t.message : String(t),\n          data: e.data\n        });\n      }\n    });\n  }\n  static async create(e) {\n    let t = null;\n    try {\n      var n, o, s;\n      const a = null != (n = e.origin) ? n : \"wss://api.elevenlabs.io\";\n      let i;\n      const r = (null == (o = e.overrides) || null == (o = o.client) ? void 0 : o.version) || u,\n        c = (null == (s = e.overrides) || null == (s = s.client) ? void 0 : s.source) || \"js_sdk\";\n      if (e.signedUrl) {\n        const t = e.signedUrl.includes(\"?\") ? \"&\" : \"?\";\n        i = `${e.signedUrl}${t}source=${c}&version=${r}`;\n      } else i = `${a}/v1/convai/conversation?agent_id=${e.agentId}&source=${c}&version=${r}`;\n      const h = [\"convai\"];\n      e.authorization && h.push(`bearer.${e.authorization}`), t = new WebSocket(i, h);\n      const v = await new Promise((n, o) => {\n          t.addEventListener(\"open\", () => {\n            var n;\n            const o = p(e);\n            null == (n = t) || n.send(JSON.stringify(o));\n          }, {\n            once: !0\n          }), t.addEventListener(\"error\", e => {\n            setTimeout(() => o(e), 0);\n          }), t.addEventListener(\"close\", o), t.addEventListener(\"message\", e => {\n            const t = JSON.parse(e.data);\n            d(t) && (\"conversation_initiation_metadata\" === t.type ? n(t.conversation_initiation_metadata_event) : console.warn(\"First received message is not conversation metadata.\"));\n          }, {\n            once: !0\n          });\n        }),\n        {\n          conversation_id: g,\n          agent_output_audio_format: f,\n          user_input_audio_format: _\n        } = v,\n        w = l(null != _ ? _ : \"pcm_16000\"),\n        b = l(f);\n      return new m(t, g, w, b);\n    } catch (e) {\n      var a;\n      throw null == (a = t) || a.close(), e;\n    }\n  }\n  close() {\n    this.socket.close();\n  }\n  sendMessage(e) {\n    this.socket.send(JSON.stringify(e));\n  }\n  async setMicMuted(e) {\n    console.warn(`WebSocket connection setMicMuted called with ${e}, but this is handled by VoiceConversation`);\n  }\n}\nfunction v(e) {\n  const t = new Uint8Array(e);\n  return window.btoa(String.fromCharCode(...t));\n}\nfunction g(e) {\n  const t = window.atob(e),\n    n = t.length,\n    o = new Uint8Array(n);\n  for (let e = 0; e < n; e++) o[e] = t.charCodeAt(e);\n  return o.buffer;\n}\nconst f = new Map();\nfunction _(e, t) {\n  return async (n, o) => {\n    const s = f.get(e);\n    if (s) return n.addModule(s);\n    if (o) try {\n      return await n.addModule(o), void f.set(e, o);\n    } catch (t) {\n      throw new Error(`Failed to load the ${e} worklet module from path: ${o}. Error: ${t}`);\n    }\n    const a = new Blob([t], {\n        type: \"application/javascript\"\n      }),\n      i = URL.createObjectURL(a);\n    try {\n      return await n.addModule(i), void f.set(e, i);\n    } catch (e) {\n      URL.revokeObjectURL(i);\n    }\n    try {\n      const o = `data:application/javascript;base64,${btoa(t)}`;\n      await n.addModule(o), f.set(e, o);\n    } catch (t) {\n      throw new Error(`Failed to load the ${e} worklet module. Make sure the browser supports AudioWorklets. If you are using a strict CSP, you may need to self-host the worklet files.`);\n    }\n  };\n}\nconst w = _(\"rawAudioProcessor\", '/*\\n * ulaw encoding logic taken from the wavefile library\\n * https://github.com/rochars/wavefile/blob/master/lib/codecs/mulaw.js\\n * USED BY @elevenlabs/client\\n */\\n\\nconst BIAS = 0x84;\\nconst CLIP = 32635;\\nconst encodeTable = [\\n  0,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,\\n  4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,\\n  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\\n  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\\n  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\\n  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\\n  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\\n  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7\\n];\\n\\nfunction encodeSample(sample) {\\n  let sign;\\n  let exponent;\\n  let mantissa;\\n  let muLawSample;\\n  sign = (sample >> 8) & 0x80;\\n  if (sign !== 0) sample = -sample;\\n  sample = sample + BIAS;\\n  if (sample > CLIP) sample = CLIP;\\n  exponent = encodeTable[(sample>>7) & 0xFF];\\n  mantissa = (sample >> (exponent+3)) & 0x0F;\\n  muLawSample = ~(sign | (exponent << 4) | mantissa);\\n  \\n  return muLawSample;\\n}\\n\\nclass RawAudioProcessor extends AudioWorkletProcessor {\\n  constructor() {\\n    super();\\n              \\n    this.port.onmessage = ({ data }) => {\\n      switch (data.type) {\\n        case \"setFormat\":\\n          this.isMuted = false;\\n          this.buffer = []; // Initialize an empty buffer\\n          this.bufferSize = data.sampleRate / 4;\\n          this.format = data.format;\\n\\n          if (globalThis.LibSampleRate && sampleRate !== data.sampleRate) {\\n            globalThis.LibSampleRate.create(1, sampleRate, data.sampleRate).then(resampler => {\\n              this.resampler = resampler;\\n            });\\n          }\\n          break;\\n        case \"setMuted\":\\n          this.isMuted = data.isMuted;\\n          break;\\n      }\\n    };\\n  }\\n  process(inputs) {\\n    if (!this.buffer) {\\n      return true;\\n    }\\n    \\n    const input = inputs[0]; // Get the first input node\\n    if (input.length > 0) {\\n      let channelData = input[0]; // Get the first channel\\'s data\\n\\n      // Resample the audio if necessary\\n      if (this.resampler) {\\n        channelData = this.resampler.full(channelData);\\n      }\\n\\n      // Add channel data to the buffer\\n      this.buffer.push(...channelData);\\n      // Get max volume \\n      let sum = 0.0;\\n      for (let i = 0; i < channelData.length; i++) {\\n        sum += channelData[i] * channelData[i];\\n      }\\n      const maxVolume = Math.sqrt(sum / channelData.length);\\n      // Check if buffer size has reached or exceeded the threshold\\n      if (this.buffer.length >= this.bufferSize) {\\n        const float32Array = this.isMuted \\n          ? new Float32Array(this.buffer.length)\\n          : new Float32Array(this.buffer);\\n\\n        let encodedArray = this.format === \"ulaw\"\\n          ? new Uint8Array(float32Array.length)\\n          : new Int16Array(float32Array.length);\\n\\n        // Iterate through the Float32Array and convert each sample to PCM16\\n        for (let i = 0; i < float32Array.length; i++) {\\n          // Clamp the value to the range [-1, 1]\\n          let sample = Math.max(-1, Math.min(1, float32Array[i]));\\n\\n          // Scale the sample to the range [-32768, 32767]\\n          let value = sample < 0 ? sample * 32768 : sample * 32767;\\n          if (this.format === \"ulaw\") {\\n            value = encodeSample(Math.round(value));\\n          }\\n\\n          encodedArray[i] = value;\\n        }\\n\\n        // Send the buffered data to the main script\\n        this.port.postMessage([encodedArray, maxVolume]);\\n\\n        // Clear the buffer after sending\\n        this.buffer = [];\\n      }\\n    }\\n    return true; // Continue processing\\n  }\\n}\\nregisterProcessor(\"rawAudioProcessor\", RawAudioProcessor);\\n');\nclass b extends c {\n  constructor(e, t, n, o, s = {}) {\n    super(s), this.conversationId = void 0, this.inputFormat = void 0, this.outputFormat = void 0, this.room = void 0, this.isConnected = !1, this.audioEventId = 1, this.audioCaptureContext = null, this.audioElements = [], this.outputDeviceId = null, this.outputAnalyser = null, this.outputFrequencyData = null, this.room = e, this.conversationId = t, this.inputFormat = n, this.outputFormat = o, this.setupRoomEventListeners();\n  }\n  static async create(n) {\n    let o;\n    if (\"conversationToken\" in n && n.conversationToken) o = n.conversationToken;else {\n      if (!(\"agentId\" in n) || !n.agentId) throw new Error(\"Either conversationToken or agentId is required for WebRTC connection\");\n      try {\n        var s, a, i;\n        const e = (null == (s = n.overrides) || null == (s = s.client) ? void 0 : s.version) || u,\n          t = (null == (a = n.overrides) || null == (a = a.client) ? void 0 : a.source) || \"js_sdk\",\n          c = `${r = null != (i = n.origin) ? i : \"https://api.elevenlabs.io\", r.replace(/^wss:\\/\\//, \"https://\")}/v1/convai/conversation/token?agent_id=${n.agentId}&source=${t}&version=${e}`,\n          l = await fetch(c);\n        if (!l.ok) throw new Error(`ElevenLabs API returned ${l.status} ${l.statusText}`);\n        if (o = (await l.json()).token, !o) throw new Error(\"No conversation token received from API\");\n      } catch (e) {\n        let t = e instanceof Error ? e.message : String(e);\n        throw e instanceof Error && e.message.includes(\"401\") && (t = \"Your agent has authentication enabled, but no signed URL or conversation token was provided.\"), new Error(`Failed to fetch conversation token for agent ${n.agentId}: ${t}`);\n      }\n    }\n    var r;\n    const c = new e();\n    try {\n      const e = `room_${Date.now()}`,\n        s = l(\"pcm_48000\"),\n        a = l(\"pcm_48000\"),\n        i = new b(c, e, s, a, n),\n        r = n.livekitUrl || \"wss://livekit.rtc.elevenlabs.io\";\n      var d;\n      await c.connect(r, o), await new Promise(e => {\n        if (i.isConnected) e();else {\n          const n = () => {\n            c.off(t.Connected, n), e();\n          };\n          c.on(t.Connected, n);\n        }\n      }), c.name && (i.conversationId = (null == (d = c.name.match(/(conv_[a-zA-Z0-9]+)/)) ? void 0 : d[0]) || c.name), await c.localParticipant.setMicrophoneEnabled(!0);\n      const u = p(n);\n      return i.debug({\n        type: h,\n        message: u\n      }), await i.sendMessage(u), i;\n    } catch (e) {\n      throw await c.disconnect(), e;\n    }\n  }\n  setupRoomEventListeners() {\n    var e = this;\n    this.room.on(t.Connected, async function () {\n      e.isConnected = !0, console.info(\"WebRTC room connected\");\n    }), this.room.on(t.Disconnected, e => {\n      this.isConnected = !1, this.disconnect({\n        reason: \"agent\",\n        context: new CloseEvent(\"close\", {\n          reason: null == e ? void 0 : e.toString()\n        })\n      });\n    }), this.room.on(t.ConnectionStateChanged, e => {\n      e === n.Disconnected && (this.isConnected = !1, this.disconnect({\n        reason: \"error\",\n        message: `LiveKit connection state changed to ${e}`,\n        context: new Event(\"connection_state_changed\")\n      }));\n    }), this.room.on(t.DataReceived, (e, t) => {\n      try {\n        const t = JSON.parse(new TextDecoder().decode(e));\n        if (\"audio\" === t.type) return;\n        d(t) ? this.handleMessage(t) : console.warn(\"Invalid socket event received:\", t);\n      } catch (t) {\n        console.warn(\"Failed to parse incoming data message:\", t), console.warn(\"Raw payload:\", new TextDecoder().decode(e));\n      }\n    }), this.room.on(t.TrackSubscribed, async function (t, n, s) {\n      if (t.kind === o.Kind.Audio && s.identity.includes(\"agent\")) {\n        const n = t,\n          o = n.attach();\n        if (o.autoplay = !0, o.controls = !1, e.outputDeviceId && o.setSinkId) try {\n          await o.setSinkId(e.outputDeviceId);\n        } catch (e) {\n          console.warn(\"Failed to set output device for new audio element:\", e);\n        }\n        o.style.display = \"none\", document.body.appendChild(o), e.audioElements.push(o), 1 === e.audioElements.length && (null == e.onDebug || e.onDebug({\n          type: \"audio_element_ready\"\n        })), await e.setupAudioCapture(n);\n      }\n    }), this.room.on(t.ActiveSpeakersChanged, async function (t) {\n      e.updateMode(t.length > 0 && t[0].identity.startsWith(\"agent\") ? \"speaking\" : \"listening\");\n    }), this.room.on(t.ParticipantDisconnected, e => {\n      var t;\n      null != (t = e.identity) && t.startsWith(\"agent\") && this.disconnect({\n        reason: \"agent\",\n        context: new CloseEvent(\"close\", {\n          reason: \"agent disconnected\"\n        })\n      });\n    });\n  }\n  close() {\n    if (this.isConnected) {\n      try {\n        this.room.localParticipant.audioTrackPublications.forEach(e => {\n          e.track && e.track.stop();\n        });\n      } catch (e) {\n        console.warn(\"Error stopping local tracks:\", e);\n      }\n      this.audioCaptureContext && (this.audioCaptureContext.close().catch(e => {\n        console.warn(\"Error closing audio capture context:\", e);\n      }), this.audioCaptureContext = null), this.audioElements.forEach(e => {\n        e.parentNode && e.parentNode.removeChild(e);\n      }), this.audioElements = [], this.room.disconnect();\n    }\n  }\n  async sendMessage(e) {\n    if (this.isConnected && this.room.localParticipant) {\n      if (!(\"user_audio_chunk\" in e)) try {\n        const t = new TextEncoder().encode(JSON.stringify(e));\n        await this.room.localParticipant.publishData(t, {\n          reliable: !0\n        });\n      } catch (t) {\n        this.debug({\n          type: \"send_message_error\",\n          message: {\n            message: e,\n            error: t\n          }\n        }), console.error(\"Failed to send message via WebRTC:\", t);\n      }\n    } else console.warn(\"Cannot send message: room not connected or no local participant\");\n  }\n  getRoom() {\n    return this.room;\n  }\n  async setMicMuted(e) {\n    if (!this.isConnected || !this.room.localParticipant) return void console.warn(\"Cannot set microphone muted: room not connected or no local participant\");\n    const t = this.room.localParticipant.getTrackPublication(o.Source.Microphone);\n    if (null != t && t.track) try {\n      e ? await t.track.mute() : await t.track.unmute();\n    } catch (t) {\n      await this.room.localParticipant.setMicrophoneEnabled(!e);\n    } else await this.room.localParticipant.setMicrophoneEnabled(!e);\n  }\n  async setupAudioCapture(e) {\n    try {\n      const t = new AudioContext();\n      this.audioCaptureContext = t, this.outputAnalyser = t.createAnalyser(), this.outputAnalyser.fftSize = 2048, this.outputAnalyser.smoothingTimeConstant = .8;\n      const n = new MediaStream([e.mediaStreamTrack]),\n        o = t.createMediaStreamSource(n);\n      o.connect(this.outputAnalyser), await w(t.audioWorklet);\n      const s = new AudioWorkletNode(t, \"rawAudioProcessor\");\n      this.outputAnalyser.connect(s), s.port.postMessage({\n        type: \"setFormat\",\n        format: this.outputFormat.format,\n        sampleRate: this.outputFormat.sampleRate\n      }), s.port.onmessage = e => {\n        const [t, n] = e.data;\n        if (n > .01) {\n          const e = v(t.buffer),\n            n = this.audioEventId++;\n          this.handleMessage({\n            type: \"audio\",\n            audio_event: {\n              audio_base_64: e,\n              event_id: n\n            }\n          });\n        }\n      }, o.connect(s);\n    } catch (e) {\n      console.warn(\"Failed to set up audio capture:\", e);\n    }\n  }\n  setAudioVolume(e) {\n    this.audioElements.forEach(t => {\n      t.volume = e;\n    });\n  }\n  async setAudioOutputDevice(e) {\n    if (!(\"setSinkId\" in HTMLAudioElement.prototype)) throw new Error(\"setSinkId is not supported in this browser\");\n    const t = this.audioElements.map(async function (t) {\n      try {\n        await t.setSinkId(e);\n      } catch (e) {\n        throw console.error(\"Failed to set sink ID for audio element:\", e), e;\n      }\n    });\n    await Promise.all(t), this.outputDeviceId = e;\n  }\n  async setAudioInputDevice(e) {\n    if (!this.isConnected || !this.room.localParticipant) throw new Error(\"Cannot change input device: room not connected or no local participant\");\n    try {\n      const t = this.room.localParticipant.getTrackPublication(o.Source.Microphone);\n      null != t && t.track && (await t.track.stop(), await this.room.localParticipant.unpublishTrack(t.track));\n      const n = {\n          deviceId: {\n            exact: e\n          },\n          echoCancellation: !0,\n          noiseSuppression: !0,\n          autoGainControl: !0,\n          channelCount: {\n            ideal: 1\n          }\n        },\n        a = await s(n);\n      await this.room.localParticipant.publishTrack(a, {\n        name: \"microphone\",\n        source: o.Source.Microphone\n      });\n    } catch (e) {\n      console.error(\"Failed to change input device:\", e);\n      try {\n        await this.room.localParticipant.setMicrophoneEnabled(!0);\n      } catch (e) {\n        console.error(\"Failed to recover microphone after device switch error:\", e);\n      }\n      throw e;\n    }\n  }\n  getOutputByteFrequencyData() {\n    return this.outputAnalyser ? (null != this.outputFrequencyData || (this.outputFrequencyData = new Uint8Array(this.outputAnalyser.frequencyBinCount)), this.outputAnalyser.getByteFrequencyData(this.outputFrequencyData), this.outputFrequencyData) : null;\n  }\n}\nasync function y(e) {\n  const t = function (e) {\n    return e.connectionType ? e.connectionType : \"conversationToken\" in e && e.conversationToken ? \"webrtc\" : \"websocket\";\n  }(e);\n  switch (t) {\n    case \"websocket\":\n      return m.create(e);\n    case \"webrtc\":\n      return b.create(e);\n    default:\n      throw new Error(`Unknown connection type: ${t}`);\n  }\n}\nfunction S() {\n  return [\"iPad Simulator\", \"iPhone Simulator\", \"iPod Simulator\", \"iPad\", \"iPhone\", \"iPod\"].includes(navigator.platform) || navigator.userAgent.includes(\"Mac\") && \"ontouchend\" in document;\n}\nasync function E(e = {\n  default: 0,\n  android: 3e3\n}) {\n  let t = e.default;\n  var n;\n  if (/android/i.test(navigator.userAgent)) t = null != (n = e.android) ? n : t;else if (S()) {\n    var o;\n    t = null != (o = e.ios) ? o : t;\n  }\n  t > 0 && (await new Promise(e => setTimeout(e, t)));\n}\nclass k extends r {\n  static async startSession(e) {\n    const t = r.getFullOptions(e);\n    t.onStatusChange && t.onStatusChange({\n      status: \"connecting\"\n    }), t.onCanSendFeedbackChange && t.onCanSendFeedbackChange({\n      canSendFeedback: !1\n    }), t.onModeChange && t.onModeChange({\n      mode: \"listening\"\n    }), t.onCanSendFeedbackChange && t.onCanSendFeedbackChange({\n      canSendFeedback: !1\n    });\n    let n = null;\n    try {\n      return await E(t.connectionDelay), n = await y(e), new k(t, n);\n    } catch (e) {\n      var o;\n      throw t.onStatusChange && t.onStatusChange({\n        status: \"disconnected\"\n      }), null == (o = n) || o.close(), e;\n    }\n  }\n}\nconst C = {\n  echoCancellation: !0,\n  noiseSuppression: !0,\n  autoGainControl: !0,\n  channelCount: {\n    ideal: 1\n  }\n};\nclass M {\n  static async create({\n    sampleRate: e,\n    format: t,\n    preferHeadphonesForIosDevices: n,\n    inputDeviceId: o,\n    workletPaths: s,\n    libsampleratePath: i\n  }) {\n    let r = null,\n      c = null;\n    try {\n      const l = a({\n        sampleRate: {\n          ideal: e\n        }\n      }, C);\n      if (S() && n) {\n        const e = (await window.navigator.mediaDevices.enumerateDevices()).find(e => \"audioinput\" === e.kind && [\"airpod\", \"headphone\", \"earphone\"].find(t => e.label.toLowerCase().includes(t)));\n        e && (l.deviceId = {\n          ideal: e.deviceId\n        });\n      }\n      o && (l.deviceId = M.getDeviceIdConstraint(o));\n      const u = navigator.mediaDevices.getSupportedConstraints().sampleRate;\n      r = new window.AudioContext(u ? {\n        sampleRate: e\n      } : {});\n      const d = r.createAnalyser();\n      if (!u) {\n        const e = i || \"https://cdn.jsdelivr.net/npm/@alexanderolsen/libsamplerate-js@2.1.2/dist/libsamplerate.worklet.js\";\n        await r.audioWorklet.addModule(e);\n      }\n      await w(r.audioWorklet, null == s ? void 0 : s.rawAudioProcessor);\n      const h = a({\n        voiceIsolation: !0\n      }, l);\n      c = await navigator.mediaDevices.getUserMedia({\n        audio: h\n      });\n      const p = r.createMediaStreamSource(c),\n        m = new AudioWorkletNode(r, \"rawAudioProcessor\");\n      return m.port.postMessage({\n        type: \"setFormat\",\n        format: t,\n        sampleRate: e\n      }), p.connect(d), d.connect(m), await r.resume(), new M(r, d, m, c, p);\n    } catch (e) {\n      var l, u;\n      throw null == (l = c) || l.getTracks().forEach(e => {\n        e.stop();\n      }), null == (u = r) || u.close(), e;\n    }\n  }\n  static getDeviceIdConstraint(e) {\n    if (e) return S() ? {\n      ideal: e\n    } : {\n      exact: e\n    };\n  }\n  constructor(e, t, n, o, s) {\n    this.context = void 0, this.analyser = void 0, this.worklet = void 0, this.inputStream = void 0, this.mediaStreamSource = void 0, this.context = e, this.analyser = t, this.worklet = n, this.inputStream = o, this.mediaStreamSource = s;\n  }\n  async close() {\n    this.inputStream.getTracks().forEach(e => {\n      e.stop();\n    }), this.mediaStreamSource.disconnect(), await this.context.close();\n  }\n  setMuted(e) {\n    this.worklet.port.postMessage({\n      type: \"setMuted\",\n      isMuted: e\n    });\n  }\n  async setInputDevice(e) {\n    try {\n      const t = a({}, C);\n      e && (t.deviceId = M.getDeviceIdConstraint(e));\n      const n = a({\n          voiceIsolation: !0\n        }, t),\n        o = await navigator.mediaDevices.getUserMedia({\n          audio: n\n        });\n      this.inputStream.getTracks().forEach(e => {\n        e.stop();\n      }), this.mediaStreamSource.disconnect(), this.inputStream = o, this.mediaStreamSource = this.context.createMediaStreamSource(o), this.mediaStreamSource.connect(this.analyser);\n    } catch (e) {\n      throw console.error(\"Failed to switch input device:\", e), e;\n    }\n  }\n}\nconst I = _(\"audioConcatProcessor\", '/*\\n * ulaw decoding logic taken from the wavefile library\\n * https://github.com/rochars/wavefile/blob/master/lib/codecs/mulaw.js\\n * USED BY @elevenlabs/client\\n */\\n\\nconst decodeTable = [0,132,396,924,1980,4092,8316,16764];\\n\\nfunction decodeSample(muLawSample) {\\n  let sign;\\n  let exponent;\\n  let mantissa;\\n  let sample;\\n  muLawSample = ~muLawSample;\\n  sign = (muLawSample & 0x80);\\n  exponent = (muLawSample >> 4) & 0x07;\\n  mantissa = muLawSample & 0x0F;\\n  sample = decodeTable[exponent] + (mantissa << (exponent+3));\\n  if (sign !== 0) sample = -sample;\\n\\n  return sample;\\n}\\n\\nclass AudioConcatProcessor extends AudioWorkletProcessor {\\n  constructor() {\\n    super();\\n    this.buffers = []; // Initialize an empty buffer\\n    this.cursor = 0;\\n    this.currentBuffer = null;\\n    this.wasInterrupted = false;\\n    this.finished = false;\\n    \\n    this.port.onmessage = ({ data }) => {\\n      switch (data.type) {\\n        case \"setFormat\":\\n          this.format = data.format;\\n          break;\\n        case \"buffer\":\\n          this.wasInterrupted = false;\\n          this.buffers.push(\\n            this.format === \"ulaw\"\\n              ? new Uint8Array(data.buffer)\\n              : new Int16Array(data.buffer)\\n          );\\n          break;\\n        case \"interrupt\":\\n          this.wasInterrupted = true;\\n          break;\\n        case \"clearInterrupted\":\\n          if (this.wasInterrupted) {\\n            this.wasInterrupted = false;\\n            this.buffers = [];\\n            this.currentBuffer = null;\\n          }\\n      }\\n    };\\n  }\\n  process(_, outputs) {\\n    let finished = false;\\n    const output = outputs[0][0];\\n    for (let i = 0; i < output.length; i++) {\\n      if (!this.currentBuffer) {\\n        if (this.buffers.length === 0) {\\n          finished = true;\\n          break;\\n        }\\n        this.currentBuffer = this.buffers.shift();\\n        this.cursor = 0;\\n      }\\n\\n      let value = this.currentBuffer[this.cursor];\\n      if (this.format === \"ulaw\") {\\n        value = decodeSample(value);\\n      }\\n      output[i] = value / 32768;\\n      this.cursor++;\\n\\n      if (this.cursor >= this.currentBuffer.length) {\\n        this.currentBuffer = null;\\n      }\\n    }\\n\\n    if (this.finished !== finished) {\\n      this.finished = finished;\\n      this.port.postMessage({ type: \"process\", finished });\\n    }\\n\\n    return true; // Continue processing\\n  }\\n}\\n\\nregisterProcessor(\"audioConcatProcessor\", AudioConcatProcessor);\\n');\nclass R {\n  static async create({\n    sampleRate: e,\n    format: t,\n    outputDeviceId: n,\n    workletPaths: o\n  }) {\n    let s = null,\n      a = null;\n    try {\n      s = new AudioContext({\n        sampleRate: e\n      });\n      const i = s.createAnalyser(),\n        r = s.createGain();\n      a = new Audio(), a.src = \"\", a.load(), a.autoplay = !0, a.style.display = \"none\", document.body.appendChild(a);\n      const c = s.createMediaStreamDestination();\n      a.srcObject = c.stream, r.connect(i), i.connect(c), await I(s.audioWorklet, null == o ? void 0 : o.audioConcatProcessor);\n      const l = new AudioWorkletNode(s, \"audioConcatProcessor\");\n      return l.port.postMessage({\n        type: \"setFormat\",\n        format: t\n      }), l.connect(r), await s.resume(), n && a.setSinkId && (await a.setSinkId(n)), new R(s, i, r, l, a);\n    } catch (e) {\n      var i, r;\n      throw null != (i = a) && i.parentNode && a.parentNode.removeChild(a), null == (r = a) || r.pause(), s && \"closed\" !== s.state && (await s.close()), e;\n    }\n  }\n  constructor(e, t, n, o, s) {\n    this.context = void 0, this.analyser = void 0, this.gain = void 0, this.worklet = void 0, this.audioElement = void 0, this.context = e, this.analyser = t, this.gain = n, this.worklet = o, this.audioElement = s;\n  }\n  async setOutputDevice(e) {\n    if (!(\"setSinkId\" in HTMLAudioElement.prototype)) throw new Error(\"setSinkId is not supported in this browser\");\n    await this.audioElement.setSinkId(e || \"\");\n  }\n  async close() {\n    this.audioElement.parentNode && this.audioElement.parentNode.removeChild(this.audioElement), this.audioElement.pause(), await this.context.close();\n  }\n}\nclass A extends r {\n  static async startSession(e) {\n    var t;\n    const n = r.getFullOptions(e);\n    n.onStatusChange && n.onStatusChange({\n      status: \"connecting\"\n    }), n.onCanSendFeedbackChange && n.onCanSendFeedbackChange({\n      canSendFeedback: !1\n    });\n    let o = null,\n      s = null,\n      i = null,\n      c = null,\n      l = null;\n    if (null == (t = e.useWakeLock) || t) try {\n      l = await navigator.wakeLock.request(\"screen\");\n    } catch (e) {}\n    try {\n      var u;\n      return c = await navigator.mediaDevices.getUserMedia({\n        audio: !0\n      }), await E(n.connectionDelay), s = await y(e), [o, i] = await Promise.all([M.create(a({}, s.inputFormat, {\n        preferHeadphonesForIosDevices: e.preferHeadphonesForIosDevices,\n        inputDeviceId: e.inputDeviceId,\n        workletPaths: e.workletPaths,\n        libsampleratePath: e.libsampleratePath\n      })), R.create(a({}, s.outputFormat, {\n        outputDeviceId: e.outputDeviceId,\n        workletPaths: e.workletPaths\n      }))]), null == (u = c) || u.getTracks().forEach(e => {\n        e.stop();\n      }), c = null, new A(n, s, o, i, l);\n    } catch (e) {\n      var d, h, p, m;\n      n.onStatusChange && n.onStatusChange({\n        status: \"disconnected\"\n      }), null == (d = c) || d.getTracks().forEach(e => {\n        e.stop();\n      }), null == (h = s) || h.close(), await (null == (p = o) ? void 0 : p.close()), await (null == (m = i) ? void 0 : m.close());\n      try {\n        var v;\n        await (null == (v = l) ? void 0 : v.release()), l = null;\n      } catch (e) {}\n      throw e;\n    }\n  }\n  constructor(e, t, n, o, s) {\n    super(e, t), this.input = void 0, this.output = void 0, this.wakeLock = void 0, this.inputFrequencyData = void 0, this.outputFrequencyData = void 0, this.onInputWorkletMessage = e => {\n      \"connected\" === this.status && this.connection.sendMessage({\n        user_audio_chunk: v(e.data[0].buffer)\n      });\n    }, this.onOutputWorkletMessage = ({\n      data: e\n    }) => {\n      \"process\" === e.type && this.updateMode(e.finished ? \"listening\" : \"speaking\");\n    }, this.addAudioBase64Chunk = e => {\n      this.output.gain.gain.cancelScheduledValues(this.output.context.currentTime), this.output.gain.gain.value = this.volume, this.output.worklet.port.postMessage({\n        type: \"clearInterrupted\"\n      }), this.output.worklet.port.postMessage({\n        type: \"buffer\",\n        buffer: g(e)\n      });\n    }, this.fadeOutAudio = () => {\n      this.updateMode(\"listening\"), this.output.worklet.port.postMessage({\n        type: \"interrupt\"\n      }), this.output.gain.gain.exponentialRampToValueAtTime(1e-4, this.output.context.currentTime + 2), setTimeout(() => {\n        this.output.gain.gain.value = this.volume, this.output.worklet.port.postMessage({\n          type: \"clearInterrupted\"\n        });\n      }, 2e3);\n    }, this.calculateVolume = e => {\n      if (0 === e.length) return 0;\n      let t = 0;\n      for (let n = 0; n < e.length; n++) t += e[n] / 255;\n      return t /= e.length, t < 0 ? 0 : t > 1 ? 1 : t;\n    }, this.setVolume = ({\n      volume: e\n    }) => {\n      const t = Number.isFinite(e) ? Math.min(1, Math.max(0, e)) : 1;\n      this.volume = t, this.connection instanceof b ? this.connection.setAudioVolume(t) : this.output.gain.gain.value = t;\n    }, this.input = n, this.output = o, this.wakeLock = s, this.input.worklet.port.onmessage = this.onInputWorkletMessage, this.output.worklet.port.onmessage = this.onOutputWorkletMessage;\n  }\n  async handleEndSession() {\n    await super.handleEndSession();\n    try {\n      var e;\n      await (null == (e = this.wakeLock) ? void 0 : e.release()), this.wakeLock = null;\n    } catch (e) {}\n    await this.input.close(), await this.output.close();\n  }\n  handleInterruption(e) {\n    super.handleInterruption(e), this.fadeOutAudio();\n  }\n  handleAudio(e) {\n    var t, n;\n    this.lastInterruptTimestamp <= e.audio_event.event_id && (null == (t = (n = this.options).onAudio) || t.call(n, e.audio_event.audio_base_64), this.connection instanceof b || this.addAudioBase64Chunk(e.audio_event.audio_base_64), this.currentEventId = e.audio_event.event_id, this.updateCanSendFeedback(), this.updateMode(\"speaking\"));\n  }\n  setMicMuted(e) {\n    this.connection instanceof b ? this.connection.setMicMuted(e) : this.input.setMuted(e);\n  }\n  getInputByteFrequencyData() {\n    return null != this.inputFrequencyData || (this.inputFrequencyData = new Uint8Array(this.input.analyser.frequencyBinCount)), this.input.analyser.getByteFrequencyData(this.inputFrequencyData), this.inputFrequencyData;\n  }\n  getOutputByteFrequencyData() {\n    return this.connection instanceof b ? this.connection.getOutputByteFrequencyData() || new Uint8Array(1024) : (null != this.outputFrequencyData || (this.outputFrequencyData = new Uint8Array(this.output.analyser.frequencyBinCount)), this.output.analyser.getByteFrequencyData(this.outputFrequencyData), this.outputFrequencyData);\n  }\n  getInputVolume() {\n    return this.calculateVolume(this.getInputByteFrequencyData());\n  }\n  getOutputVolume() {\n    return this.calculateVolume(this.getOutputByteFrequencyData());\n  }\n  async changeInputDevice({\n    sampleRate: e,\n    format: t,\n    preferHeadphonesForIosDevices: n,\n    inputDeviceId: o\n  }) {\n    try {\n      if (this.connection instanceof m) try {\n        return await this.input.setInputDevice(o), this.input;\n      } catch (e) {\n        console.warn(\"Failed to change device on existing input, recreating:\", e);\n      }\n      this.connection instanceof b && (await this.connection.setAudioInputDevice(o || \"\")), await this.input.close();\n      const s = await M.create({\n        sampleRate: null != e ? e : this.connection.inputFormat.sampleRate,\n        format: null != t ? t : this.connection.inputFormat.format,\n        preferHeadphonesForIosDevices: n,\n        inputDeviceId: o,\n        workletPaths: this.options.workletPaths,\n        libsampleratePath: this.options.libsampleratePath\n      });\n      return this.input = s, this.input.worklet.port.onmessage = this.onInputWorkletMessage, this.input;\n    } catch (e) {\n      throw console.error(\"Error changing input device\", e), e;\n    }\n  }\n  async changeOutputDevice({\n    sampleRate: e,\n    format: t,\n    outputDeviceId: n\n  }) {\n    try {\n      if (this.connection instanceof m) try {\n        return await this.output.setOutputDevice(n), this.output;\n      } catch (e) {\n        console.warn(\"Failed to change device on existing output, recreating:\", e);\n      }\n      this.connection instanceof b && (await this.connection.setAudioOutputDevice(n || \"\")), await this.output.close();\n      const o = await R.create({\n        sampleRate: null != e ? e : this.connection.outputFormat.sampleRate,\n        format: null != t ? t : this.connection.outputFormat.format,\n        outputDeviceId: n,\n        workletPaths: this.options.workletPaths\n      });\n      return this.output = o, this.output;\n    } catch (e) {\n      throw console.error(\"Error changing output device\", e), e;\n    }\n  }\n}\nfunction T(e, t, n = \"https://api.elevenlabs.io\") {\n  const o = {};\n  return \"boolean\" == typeof t ? o.feedback = t ? \"like\" : \"dislike\" : (o.rating = t.rating, o.comment = t.comment), fetch(`${n}/v1/convai/conversations/${e}/feedback`, {\n    method: \"POST\",\n    body: JSON.stringify(o),\n    headers: {\n      \"Content-Type\": \"application/json\"\n    }\n  });\n}\nclass D {\n  constructor() {\n    this.listeners = new Map();\n  }\n  on(e, t) {\n    this.listeners.has(e) || this.listeners.set(e, new Set());\n    const n = this.listeners.get(e);\n    n && n.add(t);\n  }\n  off(e, t) {\n    const n = this.listeners.get(e);\n    n && n.delete(t);\n  }\n  emit(e, ...t) {\n    const n = this.listeners.get(e);\n    n && n.forEach(e => {\n      e(...t);\n    });\n  }\n}\nvar P;\n!function (e) {\n  e.SESSION_STARTED = \"session_started\", e.PARTIAL_TRANSCRIPT = \"partial_transcript\", e.COMMITTED_TRANSCRIPT = \"committed_transcript\", e.COMMITTED_TRANSCRIPT_WITH_TIMESTAMPS = \"committed_transcript_with_timestamps\", e.AUTH_ERROR = \"auth_error\", e.ERROR = \"error\", e.OPEN = \"open\", e.CLOSE = \"close\", e.QUOTA_EXCEEDED = \"quota_exceeded\", e.COMMIT_THROTTLED = \"commit_throttled\", e.TRANSCRIBER_ERROR = \"transcriber_error\", e.UNACCEPTED_TERMS = \"unaccepted_terms\", e.RATE_LIMITED = \"rate_limited\", e.INPUT_ERROR = \"input_error\", e.QUEUE_OVERFLOW = \"queue_overflow\", e.RESOURCE_EXHAUSTED = \"resource_exhausted\", e.SESSION_TIME_LIMIT_EXCEEDED = \"session_time_limit_exceeded\", e.CHUNK_SIZE_EXCEEDED = \"chunk_size_exceeded\", e.INSUFFICIENT_AUDIO_ACTIVITY = \"insufficient_audio_activity\";\n}(P || (P = {}));\nclass F {\n  constructor(e) {\n    this.websocket = null, this.eventEmitter = new D(), this.currentSampleRate = 16e3, this._audioCleanup = void 0, this.currentSampleRate = e;\n  }\n  setWebSocket(e) {\n    this.websocket = e, this.websocket.readyState === WebSocket.OPEN ? this.eventEmitter.emit(P.OPEN) : this.websocket.addEventListener(\"open\", () => {\n      this.eventEmitter.emit(P.OPEN);\n    }), this.websocket.addEventListener(\"message\", e => {\n      try {\n        const t = JSON.parse(e.data);\n        switch (t.message_type) {\n          case \"session_started\":\n            this.eventEmitter.emit(P.SESSION_STARTED, t);\n            break;\n          case \"partial_transcript\":\n            this.eventEmitter.emit(P.PARTIAL_TRANSCRIPT, t);\n            break;\n          case \"committed_transcript\":\n            this.eventEmitter.emit(P.COMMITTED_TRANSCRIPT, t);\n            break;\n          case \"committed_transcript_with_timestamps\":\n            this.eventEmitter.emit(P.COMMITTED_TRANSCRIPT_WITH_TIMESTAMPS, t);\n            break;\n          case \"auth_error\":\n            this.eventEmitter.emit(P.AUTH_ERROR, t), this.eventEmitter.emit(P.ERROR, t);\n            break;\n          case \"quota_exceeded\":\n            this.eventEmitter.emit(P.QUOTA_EXCEEDED, t), this.eventEmitter.emit(P.ERROR, t);\n            break;\n          case \"commit_throttled\":\n            this.eventEmitter.emit(P.COMMIT_THROTTLED, t), this.eventEmitter.emit(P.ERROR, t);\n            break;\n          case \"transcriber_error\":\n            this.eventEmitter.emit(P.TRANSCRIBER_ERROR, t), this.eventEmitter.emit(P.ERROR, t);\n            break;\n          case \"unaccepted_terms\":\n            this.eventEmitter.emit(P.UNACCEPTED_TERMS, t), this.eventEmitter.emit(P.ERROR, t);\n            break;\n          case \"rate_limited\":\n            this.eventEmitter.emit(P.RATE_LIMITED, t), this.eventEmitter.emit(P.ERROR, t);\n            break;\n          case \"input_error\":\n            this.eventEmitter.emit(P.INPUT_ERROR, t), this.eventEmitter.emit(P.ERROR, t);\n            break;\n          case \"queue_overflow\":\n            this.eventEmitter.emit(P.QUEUE_OVERFLOW, t), this.eventEmitter.emit(P.ERROR, t);\n            break;\n          case \"resource_exhausted\":\n            this.eventEmitter.emit(P.RESOURCE_EXHAUSTED, t), this.eventEmitter.emit(P.ERROR, t);\n            break;\n          case \"session_time_limit_exceeded\":\n            this.eventEmitter.emit(P.SESSION_TIME_LIMIT_EXCEEDED, t), this.eventEmitter.emit(P.ERROR, t);\n            break;\n          case \"chunk_size_exceeded\":\n            this.eventEmitter.emit(P.CHUNK_SIZE_EXCEEDED, t), this.eventEmitter.emit(P.ERROR, t);\n            break;\n          case \"insufficient_audio_activity\":\n            this.eventEmitter.emit(P.INSUFFICIENT_AUDIO_ACTIVITY, t), this.eventEmitter.emit(P.ERROR, t);\n            break;\n          case \"error\":\n            this.eventEmitter.emit(P.ERROR, t);\n            break;\n          default:\n            console.warn(\"Unknown message type:\", t);\n        }\n      } catch (t) {\n        console.error(\"Failed to parse WebSocket message:\", t, e.data), this.eventEmitter.emit(P.ERROR, new Error(`Failed to parse message: ${t}`));\n      }\n    }), this.websocket.addEventListener(\"error\", e => {\n      console.error(\"WebSocket error:\", e), this.eventEmitter.emit(P.ERROR, e);\n    }), this.websocket.addEventListener(\"close\", e => {\n      if (console.log(`WebSocket closed: code=${e.code}, reason=\"${e.reason}\", wasClean=${e.wasClean}`), !e.wasClean || 1e3 !== e.code && 1005 !== e.code) {\n        const t = `WebSocket closed unexpectedly: ${e.code} - ${e.reason || \"No reason provided\"}`;\n        console.error(t), this.eventEmitter.emit(P.ERROR, new Error(t));\n      }\n      this.eventEmitter.emit(P.CLOSE, e);\n    });\n  }\n  on(e, t) {\n    this.eventEmitter.on(e, t);\n  }\n  off(e, t) {\n    this.eventEmitter.off(e, t);\n  }\n  send(e) {\n    var t, n;\n    if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN) throw new Error(\"WebSocket is not connected\");\n    const o = {\n      message_type: \"input_audio_chunk\",\n      audio_base_64: e.audioBase64,\n      commit: null != (t = e.commit) && t,\n      sample_rate: null != (n = e.sampleRate) ? n : this.currentSampleRate,\n      previous_text: e.previousText\n    };\n    this.websocket.send(JSON.stringify(o));\n  }\n  commit() {\n    if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN) throw new Error(\"WebSocket is not connected\");\n    this.websocket.send(JSON.stringify({\n      message_type: \"input_audio_chunk\",\n      audio_base_64: \"\",\n      commit: !0,\n      sample_rate: this.currentSampleRate\n    }));\n  }\n  close() {\n    this._audioCleanup && this._audioCleanup(), this.websocket && this.websocket.close();\n  }\n}\nconst x = _(\"scribeAudioProcessor\", '/*\\n * Scribe Audio Processor for converting microphone audio to PCM16 format\\n * USED BY @elevenlabs/client\\n */\\n\\nclass ScribeAudioProcessor extends AudioWorkletProcessor {\\n  constructor() {\\n    super();\\n    this.buffer = [];\\n    this.bufferSize = 4096; // Buffer size for optimal chunk transmission\\n  }\\n\\n  process(inputs) {\\n    const input = inputs[0];\\n    if (input.length > 0) {\\n      const channelData = input[0]; // Get first channel (mono)\\n\\n      // Add incoming audio to buffer\\n      this.buffer.push(...channelData);\\n\\n      // When buffer reaches threshold, convert and send\\n      if (this.buffer.length >= this.bufferSize) {\\n        const float32Array = new Float32Array(this.buffer);\\n        const int16Array = new Int16Array(float32Array.length);\\n\\n        // Convert Float32 [-1, 1] to Int16 [-32768, 32767]\\n        for (let i = 0; i < float32Array.length; i++) {\\n          // Clamp the value to prevent overflow\\n          const sample = Math.max(-1, Math.min(1, float32Array[i]));\\n          // Scale to PCM16 range\\n          int16Array[i] = sample < 0 ? sample * 32768 : sample * 32767;\\n        }\\n\\n        // Send to main thread as transferable ArrayBuffer\\n        this.port.postMessage(\\n          {\\n            audioData: int16Array.buffer\\n          },\\n          [int16Array.buffer]\\n        );\\n\\n        // Clear buffer\\n        this.buffer = [];\\n      }\\n    }\\n\\n    return true; // Continue processing\\n  }\\n}\\n\\nregisterProcessor(\"scribeAudioProcessor\", ScribeAudioProcessor);\\n\\n');\nvar O, U;\n!function (e) {\n  e.PCM_8000 = \"pcm_8000\", e.PCM_16000 = \"pcm_16000\", e.PCM_22050 = \"pcm_22050\", e.PCM_24000 = \"pcm_24000\", e.PCM_44100 = \"pcm_44100\", e.PCM_48000 = \"pcm_48000\", e.ULAW_8000 = \"ulaw_8000\";\n}(O || (O = {})), function (e) {\n  e.MANUAL = \"manual\", e.VAD = \"vad\";\n}(U || (U = {}));\nclass L {\n  static getWebSocketUri(e = L.DEFAULT_BASE_URI) {\n    return `${e}/v1/speech-to-text/realtime`;\n  }\n  static buildWebSocketUri(e) {\n    const t = L.getWebSocketUri(e.baseUri),\n      n = new URLSearchParams();\n    if (n.append(\"model_id\", e.modelId), n.append(\"token\", e.token), void 0 !== e.commitStrategy && n.append(\"commit_strategy\", e.commitStrategy), void 0 !== e.vadSilenceThresholdSecs) {\n      if (e.vadSilenceThresholdSecs <= .3 || e.vadSilenceThresholdSecs > 3) throw new Error(\"vadSilenceThresholdSecs must be between 0.3 and 3.0\");\n      n.append(\"vad_silence_threshold_secs\", e.vadSilenceThresholdSecs.toString());\n    }\n    if (void 0 !== e.vadThreshold) {\n      if (e.vadThreshold < .1 || e.vadThreshold > .9) throw new Error(\"vadThreshold must be between 0.1 and 0.9\");\n      n.append(\"vad_threshold\", e.vadThreshold.toString());\n    }\n    if (void 0 !== e.minSpeechDurationMs) {\n      if (e.minSpeechDurationMs <= 50 || e.minSpeechDurationMs > 2e3) throw new Error(\"minSpeechDurationMs must be between 50 and 2000\");\n      n.append(\"min_speech_duration_ms\", e.minSpeechDurationMs.toString());\n    }\n    if (void 0 !== e.minSilenceDurationMs) {\n      if (e.minSilenceDurationMs <= 50 || e.minSilenceDurationMs > 2e3) throw new Error(\"minSilenceDurationMs must be between 50 and 2000\");\n      n.append(\"min_silence_duration_ms\", e.minSilenceDurationMs.toString());\n    }\n    void 0 !== e.languageCode && n.append(\"language_code\", e.languageCode), void 0 !== e.includeTimestamps && n.append(\"include_timestamps\", e.includeTimestamps ? \"true\" : \"false\");\n    const o = n.toString();\n    return o ? `${t}?${o}` : t;\n  }\n  static connect(e) {\n    if (!e.modelId) throw new Error(\"modelId is required\");\n    const t = new F(\"microphone\" in e && e.microphone ? 16e3 : e.sampleRate),\n      n = L.buildWebSocketUri(e),\n      o = new WebSocket(n);\n    return \"microphone\" in e && e.microphone && o.addEventListener(\"open\", () => {\n      L.streamFromMicrophone(e, t);\n    }), t.setWebSocket(o), t;\n  }\n  static async streamFromMicrophone(e, t) {\n    try {\n      var n, o, s, a, i, r, c, l, u;\n      const d = await navigator.mediaDevices.getUserMedia({\n          audio: {\n            deviceId: null == (n = e.microphone) ? void 0 : n.deviceId,\n            echoCancellation: null == (o = null == (s = e.microphone) ? void 0 : s.echoCancellation) || o,\n            noiseSuppression: null == (a = null == (i = e.microphone) ? void 0 : i.noiseSuppression) || a,\n            autoGainControl: null == (r = null == (c = e.microphone) ? void 0 : c.autoGainControl) || r,\n            channelCount: null != (l = null == (u = e.microphone) ? void 0 : u.channelCount) ? l : 1,\n            sampleRate: {\n              ideal: 16e3\n            }\n          }\n        }),\n        h = new AudioContext({\n          sampleRate: 16e3\n        });\n      await x(h.audioWorklet);\n      const p = h.createMediaStreamSource(d),\n        m = new AudioWorkletNode(h, \"scribeAudioProcessor\");\n      m.port.onmessage = e => {\n        const {\n            audioData: n\n          } = e.data,\n          o = new Uint8Array(n);\n        let s = \"\";\n        for (let e = 0; e < o.length; e++) s += String.fromCharCode(o[e]);\n        const a = btoa(s);\n        t.send({\n          audioBase64: a\n        });\n      }, p.connect(m), \"suspended\" === h.state && (await h.resume()), t._audioCleanup = () => {\n        d.getTracks().forEach(e => {\n          e.stop();\n        }), p.disconnect(), m.disconnect(), h.close();\n      };\n    } catch (e) {\n      throw console.error(\"Failed to start microphone streaming:\", e), e;\n    }\n  }\n}\nL.DEFAULT_BASE_URI = \"wss://api.elevenlabs.io\";\nclass N extends r {\n  static startSession(e) {\n    return e.textOnly ? k.startSession(e) : A.startSession(e);\n  }\n}\nexport { O as AudioFormat, U as CommitStrategy, N as Conversation, M as Input, R as Output, F as RealtimeConnection, P as RealtimeEvents, L as Scribe, k as TextConversation, A as VoiceConversation, b as WebRTCConnection, m as WebSocketConnection, y as createConnection, T as postOverallFeedback };","map":{"version":3,"names":["i","Uint8Array","r","getFullOptions","e","a","clientTools","onConnect","onDebug","onDisconnect","onError","onMessage","onAudio","onModeChange","onStatusChange","onCanSendFeedbackChange","onInterruption","constructor","t","n","options","connection","lastInterruptTimestamp","mode","status","volume","currentEventId","lastFeedbackEventId","canSendFeedback","endSessionWithDetails","updateStatus","handleEndSession","type","handleInterruption","handleAgentResponse","handleUserTranscript","handleTentativeAgentResponse","handleClientToolCall","Error","message","String","clientToolName","client_tool_call","tool_name","toolCallId","tool_call_id","handleAudio","handleVadScore","sendMessage","event_id","ping_event","handleMCPToolCall","handleMCPConnectionStatus","handleAgentToolRequest","handleAgentToolResponse","handleConversationMetadata","handleAsrInitiationMetadata","handleAgentChatResponsePart","handleErrorEvent","setVolume","conversationId","updateMode","endSession","reason","close","updateCanSendFeedback","interruption_event","source","role","agent_response_event","agent_response","user_transcription_event","user_transcript","response","tentative_agent_response_internal_event","tentative_agent_response","onVadScore","vadScore","vad_score_event","vad_score","Object","prototype","hasOwnProperty","call","parameters","o","JSON","stringify","result","is_error","onUnhandledClientToolCall","onMCPToolCall","mcp_tool_call","onMCPConnectionStatus","mcp_connection_status","onAgentToolRequest","agent_tool_request","agent_tool_response","context","CloseEvent","onAgentToolResponse","onConversationMetadata","conversation_initiation_metadata_event","onAsrInitiationMetadata","asr_initiation_metadata_event","onAgentChatResponsePart","text_response_part","error_event","error_type","errorType","code","debugMessage","debug_message","details","Event","console","error","getId","isOpen","setMicMuted","getInputByteFrequencyData","getOutputByteFrequencyData","getInputVolume","getOutputVolume","sendFeedback","score","warn","sendContextualUpdate","text","sendUserMessage","sendUserActivity","sendMCPToolApprovalResult","is_approved","c","queue","disconnectionDetails","onDisconnectCallback","onMessageCallback","onModeChangeCallback","debug","length","queueMicrotask","forEach","disconnect","handleMessage","push","l","split","includes","Number","parseInt","isNaN","format","sampleRate","u","d","h","p","s","overrides","conversation_config_override","agent","prompt","first_message","firstMessage","language","tts","voice_id","voiceId","conversation","text_only","textOnly","customLlmExtraBody","custom_llm_extra_body","dynamicVariables","dynamic_variables","userId","user_id","client","source_info","version","m","socket","inputFormat","outputFormat","addEventListener","setTimeout","parse","data","create","origin","signedUrl","agentId","authorization","WebSocket","v","Promise","send","once","conversation_id","g","agent_output_audio_format","f","user_input_audio_format","_","w","b","window","btoa","fromCharCode","atob","charCodeAt","buffer","Map","get","addModule","set","Blob","URL","createObjectURL","revokeObjectURL","room","isConnected","audioEventId","audioCaptureContext","audioElements","outputDeviceId","outputAnalyser","outputFrequencyData","setupRoomEventListeners","conversationToken","replace","fetch","ok","statusText","json","token","Date","now","livekitUrl","connect","off","Connected","on","name","match","localParticipant","setMicrophoneEnabled","info","Disconnected","toString","ConnectionStateChanged","DataReceived","TextDecoder","decode","TrackSubscribed","kind","Kind","Audio","identity","attach","autoplay","controls","setSinkId","style","display","document","body","appendChild","setupAudioCapture","ActiveSpeakersChanged","startsWith","ParticipantDisconnected","audioTrackPublications","track","stop","catch","parentNode","removeChild","TextEncoder","encode","publishData","reliable","getRoom","getTrackPublication","Source","Microphone","mute","unmute","AudioContext","createAnalyser","fftSize","smoothingTimeConstant","MediaStream","mediaStreamTrack","createMediaStreamSource","audioWorklet","AudioWorkletNode","port","postMessage","onmessage","audio_event","audio_base_64","setAudioVolume","setAudioOutputDevice","HTMLAudioElement","map","all","setAudioInputDevice","unpublishTrack","deviceId","exact","echoCancellation","noiseSuppression","autoGainControl","channelCount","ideal","publishTrack","frequencyBinCount","getByteFrequencyData","y","connectionType","S","navigator","platform","userAgent","E","default","android","test","ios","k","startSession","connectionDelay","C","M","preferHeadphonesForIosDevices","inputDeviceId","workletPaths","libsampleratePath","mediaDevices","enumerateDevices","find","label","toLowerCase","getDeviceIdConstraint","getSupportedConstraints","rawAudioProcessor","voiceIsolation","getUserMedia","audio","resume","getTracks","analyser","worklet","inputStream","mediaStreamSource","setMuted","isMuted","setInputDevice","I","R","createGain","src","load","createMediaStreamDestination","srcObject","stream","audioConcatProcessor","pause","state","gain","audioElement","setOutputDevice","A","useWakeLock","wakeLock","request","release","input","output","inputFrequencyData","onInputWorkletMessage","user_audio_chunk","onOutputWorkletMessage","finished","addAudioBase64Chunk","cancelScheduledValues","currentTime","value","fadeOutAudio","exponentialRampToValueAtTime","calculateVolume","isFinite","Math","min","max","changeInputDevice","changeOutputDevice","T","feedback","rating","comment","method","headers","D","listeners","has","Set","add","delete","emit","P","SESSION_STARTED","PARTIAL_TRANSCRIPT","COMMITTED_TRANSCRIPT","COMMITTED_TRANSCRIPT_WITH_TIMESTAMPS","AUTH_ERROR","ERROR","OPEN","CLOSE","QUOTA_EXCEEDED","COMMIT_THROTTLED","TRANSCRIBER_ERROR","UNACCEPTED_TERMS","RATE_LIMITED","INPUT_ERROR","QUEUE_OVERFLOW","RESOURCE_EXHAUSTED","SESSION_TIME_LIMIT_EXCEEDED","CHUNK_SIZE_EXCEEDED","INSUFFICIENT_AUDIO_ACTIVITY","F","websocket","eventEmitter","currentSampleRate","_audioCleanup","setWebSocket","readyState","message_type","log","wasClean","audioBase64","commit","sample_rate","previous_text","previousText","x","O","U","PCM_8000","PCM_16000","PCM_22050","PCM_24000","PCM_44100","PCM_48000","ULAW_8000","MANUAL","VAD","L","getWebSocketUri","DEFAULT_BASE_URI","buildWebSocketUri","baseUri","URLSearchParams","append","modelId","commitStrategy","vadSilenceThresholdSecs","vadThreshold","minSpeechDurationMs","minSilenceDurationMs","languageCode","includeTimestamps","microphone","streamFromMicrophone","audioData","N","AudioFormat","CommitStrategy","Conversation","Input","Output","RealtimeConnection","RealtimeEvents","Scribe","TextConversation","VoiceConversation","WebRTCConnection","WebSocketConnection","createConnection","postOverallFeedback"],"sources":["C:\\Users\\neeha\\echocode\\frontend\\node_modules\\@elevenlabs\\client\\src\\BaseConversation.ts","C:\\Users\\neeha\\echocode\\frontend\\node_modules\\@elevenlabs\\client\\src\\utils\\BaseConnection.ts","C:\\Users\\neeha\\echocode\\frontend\\node_modules\\@elevenlabs\\client\\src\\version.ts","C:\\Users\\neeha\\echocode\\frontend\\node_modules\\@elevenlabs\\client\\src\\utils\\events.ts","C:\\Users\\neeha\\echocode\\frontend\\node_modules\\@elevenlabs\\client\\src\\utils\\overrides.ts","C:\\Users\\neeha\\echocode\\frontend\\node_modules\\@elevenlabs\\client\\src\\utils\\WebSocketConnection.ts","C:\\Users\\neeha\\echocode\\frontend\\node_modules\\@elevenlabs\\client\\src\\utils\\audio.ts","C:\\Users\\neeha\\echocode\\frontend\\node_modules\\@elevenlabs\\client\\src\\utils\\createWorkletModuleLoader.ts","C:\\Users\\neeha\\echocode\\frontend\\node_modules\\@elevenlabs\\client\\src\\utils\\rawAudioProcessor.generated.ts","C:\\Users\\neeha\\echocode\\frontend\\node_modules\\@elevenlabs\\client\\src\\utils\\WebRTCConnection.ts","C:\\Users\\neeha\\echocode\\frontend\\node_modules\\@elevenlabs\\client\\src\\utils\\ConnectionFactory.ts","C:\\Users\\neeha\\echocode\\frontend\\node_modules\\@elevenlabs\\client\\src\\utils\\compatibility.ts","C:\\Users\\neeha\\echocode\\frontend\\node_modules\\@elevenlabs\\client\\src\\utils\\applyDelay.ts","C:\\Users\\neeha\\echocode\\frontend\\node_modules\\@elevenlabs\\client\\src\\TextConversation.ts","C:\\Users\\neeha\\echocode\\frontend\\node_modules\\@elevenlabs\\client\\src\\utils\\input.ts","C:\\Users\\neeha\\echocode\\frontend\\node_modules\\@elevenlabs\\client\\src\\utils\\audioConcatProcessor.generated.ts","C:\\Users\\neeha\\echocode\\frontend\\node_modules\\@elevenlabs\\client\\src\\utils\\output.ts","C:\\Users\\neeha\\echocode\\frontend\\node_modules\\@elevenlabs\\client\\src\\VoiceConversation.ts","C:\\Users\\neeha\\echocode\\frontend\\node_modules\\@elevenlabs\\client\\src\\utils\\postOverallFeedback.ts","C:\\Users\\neeha\\echocode\\frontend\\node_modules\\@elevenlabs\\client\\src\\scribe\\connection.ts","C:\\Users\\neeha\\echocode\\frontend\\node_modules\\@elevenlabs\\client\\src\\utils\\scribeAudioProcessor.generated.ts","C:\\Users\\neeha\\echocode\\frontend\\node_modules\\@elevenlabs\\client\\src\\scribe\\scribe.ts","C:\\Users\\neeha\\echocode\\frontend\\node_modules\\@elevenlabs\\client\\src\\index.ts"],"sourcesContent":["import { Callbacks, Mode, Status } from \"@elevenlabs/types\";\nimport type {\n  BaseConnection,\n  DisconnectionDetails,\n  SessionConfig,\n  FormatConfig,\n} from \"./utils/BaseConnection\";\nimport type {\n  AgentAudioEvent,\n  AgentChatResponsePartEvent,\n  AgentResponseEvent,\n  ClientToolCallEvent,\n  IncomingSocketEvent,\n  InternalTentativeAgentResponseEvent,\n  InterruptionEvent,\n  UserTranscriptionEvent,\n  VadScoreEvent,\n  MCPToolCallClientEvent,\n  AgentToolResponseEvent,\n  ConversationMetadataEvent,\n  AsrInitiationMetadataEvent,\n  MCPConnectionStatusEvent,\n  ErrorMessageEvent,\n  AgentToolRequestEvent,\n} from \"./utils/events\";\nimport type { InputConfig } from \"./utils/input\";\nimport type { OutputConfig } from \"./utils/output\";\n\nexport type { Role, Mode, Status, Callbacks } from \"@elevenlabs/types\";\n\n/** Allows self-hosting the worklets to avoid whitelisting blob: and data: in the CSP script-src  */\nexport type AudioWorkletConfig = {\n  workletPaths?: {\n    rawAudioProcessor?: string;\n    audioConcatProcessor?: string;\n  };\n  libsampleratePath?: string;\n};\n\nexport type Options = SessionConfig &\n  Callbacks &\n  ClientToolsConfig &\n  InputConfig &\n  OutputConfig &\n  AudioWorkletConfig;\n\nexport type PartialOptions = SessionConfig &\n  Partial<Callbacks> &\n  Partial<ClientToolsConfig> &\n  Partial<InputConfig> &\n  Partial<OutputConfig> &\n  Partial<FormatConfig> &\n  Partial<AudioWorkletConfig>;\n\nexport type ClientToolsConfig = {\n  clientTools: Record<\n    string,\n    (\n      parameters: any\n    ) => Promise<string | number | void> | string | number | void\n  >;\n};\n\nconst EMPTY_FREQUENCY_DATA = new Uint8Array(0);\n\nexport class BaseConversation {\n  protected lastInterruptTimestamp = 0;\n  protected mode: Mode = \"listening\";\n  protected status: Status = \"connecting\";\n  protected volume = 1;\n  protected currentEventId = 1;\n  protected lastFeedbackEventId = 0;\n  protected canSendFeedback = false;\n\n  protected static getFullOptions(partialOptions: PartialOptions): Options {\n    return {\n      clientTools: {},\n      onConnect: () => {},\n      onDebug: () => {},\n      onDisconnect: () => {},\n      onError: () => {},\n      onMessage: () => {},\n      onAudio: () => {},\n      onModeChange: () => {},\n      onStatusChange: () => {},\n      onCanSendFeedbackChange: () => {},\n      onInterruption: () => {},\n      ...partialOptions,\n    };\n  }\n\n  protected constructor(\n    protected readonly options: Options,\n    protected readonly connection: BaseConnection\n  ) {\n    if (this.options.onConnect) {\n      this.options.onConnect({ conversationId: connection.conversationId });\n    }\n    this.connection.onMessage(this.onMessage);\n    this.connection.onDisconnect(this.endSessionWithDetails);\n    this.connection.onModeChange(mode => this.updateMode(mode));\n    this.updateStatus(\"connected\");\n  }\n\n  public endSession() {\n    return this.endSessionWithDetails({ reason: \"user\" });\n  }\n\n  private endSessionWithDetails = async (details: DisconnectionDetails) => {\n    if (this.status !== \"connected\" && this.status !== \"connecting\") return;\n    this.updateStatus(\"disconnecting\");\n    await this.handleEndSession();\n    this.updateStatus(\"disconnected\");\n    if (this.options.onDisconnect) {\n      this.options.onDisconnect(details);\n    }\n  };\n\n  protected async handleEndSession() {\n    this.connection.close();\n  }\n\n  protected updateMode(mode: Mode) {\n    if (mode !== this.mode) {\n      this.mode = mode;\n      if (this.options.onModeChange) {\n        this.options.onModeChange({ mode });\n      }\n    }\n  }\n\n  protected updateStatus(status: Status) {\n    if (status !== this.status) {\n      this.status = status;\n      if (this.options.onStatusChange) {\n        this.options.onStatusChange({ status });\n      }\n    }\n  }\n\n  protected updateCanSendFeedback() {\n    const canSendFeedback = this.currentEventId !== this.lastFeedbackEventId;\n    if (this.canSendFeedback !== canSendFeedback) {\n      this.canSendFeedback = canSendFeedback;\n      if (this.options.onCanSendFeedbackChange) {\n        this.options.onCanSendFeedbackChange({ canSendFeedback });\n      }\n    }\n  }\n\n  protected handleInterruption(event: InterruptionEvent) {\n    if (event.interruption_event) {\n      this.lastInterruptTimestamp = event.interruption_event.event_id;\n\n      if (this.options.onInterruption) {\n        this.options.onInterruption({\n          event_id: event.interruption_event.event_id,\n        });\n      }\n    }\n  }\n\n  protected handleAgentResponse(event: AgentResponseEvent) {\n    if (this.options.onMessage) {\n      this.options.onMessage({\n        source: \"ai\",\n        role: \"agent\",\n        message: event.agent_response_event.agent_response,\n      });\n    }\n  }\n\n  protected handleUserTranscript(event: UserTranscriptionEvent) {\n    if (this.options.onMessage) {\n      this.options.onMessage({\n        source: \"user\",\n        role: \"user\",\n        message: event.user_transcription_event.user_transcript,\n      });\n    }\n  }\n\n  protected handleTentativeAgentResponse(\n    event: InternalTentativeAgentResponseEvent\n  ) {\n    if (this.options.onDebug) {\n      this.options.onDebug({\n        type: \"tentative_agent_response\",\n        response:\n          event.tentative_agent_response_internal_event\n            .tentative_agent_response,\n      });\n    }\n  }\n\n  protected handleVadScore(event: VadScoreEvent) {\n    if (this.options.onVadScore) {\n      this.options.onVadScore({\n        vadScore: event.vad_score_event.vad_score,\n      });\n    }\n  }\n\n  protected async handleClientToolCall(event: ClientToolCallEvent) {\n    if (\n      Object.prototype.hasOwnProperty.call(\n        this.options.clientTools,\n        event.client_tool_call.tool_name\n      )\n    ) {\n      try {\n        const result =\n          (await this.options.clientTools[event.client_tool_call.tool_name](\n            event.client_tool_call.parameters\n          )) ?? \"Client tool execution successful.\"; // default client-tool call response\n\n        // The API expects result to be a string, so we need to convert it if it's not already a string\n        const formattedResult =\n          typeof result === \"object\" ? JSON.stringify(result) : String(result);\n\n        this.connection.sendMessage({\n          type: \"client_tool_result\",\n          tool_call_id: event.client_tool_call.tool_call_id,\n          result: formattedResult,\n          is_error: false,\n        });\n      } catch (e) {\n        this.onError(\n          `Client tool execution failed with following error: ${(e as Error)?.message}`,\n          {\n            clientToolName: event.client_tool_call.tool_name,\n          }\n        );\n        this.connection.sendMessage({\n          type: \"client_tool_result\",\n          tool_call_id: event.client_tool_call.tool_call_id,\n          result: `Client tool execution failed: ${(e as Error)?.message}`,\n          is_error: true,\n        });\n      }\n    } else {\n      if (this.options.onUnhandledClientToolCall) {\n        this.options.onUnhandledClientToolCall(event.client_tool_call);\n\n        return;\n      }\n\n      this.onError(\n        `Client tool with name ${event.client_tool_call.tool_name} is not defined on client`,\n        {\n          clientToolName: event.client_tool_call.tool_name,\n        }\n      );\n      this.connection.sendMessage({\n        type: \"client_tool_result\",\n        tool_call_id: event.client_tool_call.tool_call_id,\n        result: `Client tool with name ${event.client_tool_call.tool_name} is not defined on client`,\n        is_error: true,\n      });\n    }\n  }\n\n  protected handleAudio(event: AgentAudioEvent) {}\n\n  protected handleMCPToolCall(event: MCPToolCallClientEvent) {\n    if (this.options.onMCPToolCall) {\n      this.options.onMCPToolCall(event.mcp_tool_call);\n    }\n  }\n\n  protected handleMCPConnectionStatus(event: MCPConnectionStatusEvent) {\n    if (this.options.onMCPConnectionStatus) {\n      this.options.onMCPConnectionStatus(event.mcp_connection_status);\n    }\n  }\n\n  protected handleAgentToolRequest(event: AgentToolRequestEvent) {\n    if (this.options.onAgentToolRequest) {\n      this.options.onAgentToolRequest(event.agent_tool_request);\n    }\n  }\n\n  protected handleAgentToolResponse(event: AgentToolResponseEvent) {\n    if (event.agent_tool_response.tool_name === \"end_call\") {\n      this.endSessionWithDetails({\n        reason: \"agent\",\n        context: new CloseEvent(\"end_call\", { reason: \"Agent ended the call\" }),\n      });\n    }\n\n    if (this.options.onAgentToolResponse) {\n      this.options.onAgentToolResponse(event.agent_tool_response);\n    }\n  }\n\n  protected handleConversationMetadata(event: ConversationMetadataEvent) {\n    if (this.options.onConversationMetadata) {\n      this.options.onConversationMetadata(\n        event.conversation_initiation_metadata_event\n      );\n    }\n  }\n\n  protected handleAsrInitiationMetadata(event: AsrInitiationMetadataEvent) {\n    if (this.options.onAsrInitiationMetadata) {\n      this.options.onAsrInitiationMetadata(event.asr_initiation_metadata_event);\n    }\n  }\n\n  protected handleAgentChatResponsePart(event: AgentChatResponsePartEvent) {\n    if (this.options.onAgentChatResponsePart) {\n      this.options.onAgentChatResponsePart(event.text_response_part);\n    }\n  }\n\n  protected handleErrorEvent(event: ErrorMessageEvent) {\n    const errorType = event.error_event.error_type;\n    const message =\n      event.error_event.message || event.error_event.reason || \"Unknown error\";\n\n    if (errorType === \"max_duration_exceeded\") {\n      this.endSessionWithDetails({\n        reason: \"error\",\n        message: message,\n        context: new Event(\"max_duration_exceeded\"),\n      });\n      return;\n    }\n\n    this.onError(`Server error: ${message}`, {\n      errorType,\n      code: event.error_event.code,\n      debugMessage: event.error_event.debug_message,\n      details: event.error_event.details,\n    });\n  }\n\n  private onMessage = async (parsedEvent: IncomingSocketEvent) => {\n    switch (parsedEvent.type) {\n      case \"interruption\": {\n        this.handleInterruption(parsedEvent);\n        return;\n      }\n      case \"agent_response\": {\n        this.handleAgentResponse(parsedEvent);\n        return;\n      }\n      case \"user_transcript\": {\n        this.handleUserTranscript(parsedEvent);\n        return;\n      }\n      case \"internal_tentative_agent_response\": {\n        this.handleTentativeAgentResponse(parsedEvent);\n        return;\n      }\n      case \"client_tool_call\": {\n        try {\n          await this.handleClientToolCall(parsedEvent);\n        } catch (error) {\n          this.onError(\n            `Unexpected error in client tool call handling: ${error instanceof Error ? error.message : String(error)}`,\n            {\n              clientToolName: parsedEvent.client_tool_call.tool_name,\n              toolCallId: parsedEvent.client_tool_call.tool_call_id,\n            }\n          );\n        }\n        return;\n      }\n      case \"audio\": {\n        this.handleAudio(parsedEvent);\n        return;\n      }\n\n      case \"vad_score\": {\n        this.handleVadScore(parsedEvent);\n        return;\n      }\n\n      case \"ping\": {\n        this.connection.sendMessage({\n          type: \"pong\",\n          event_id: parsedEvent.ping_event.event_id,\n        });\n        // parsedEvent.ping_event.ping_ms can be used on client side, for example\n        // to warn if ping is too high that experience might be degraded.\n        return;\n      }\n\n      case \"mcp_tool_call\": {\n        this.handleMCPToolCall(parsedEvent);\n        return;\n      }\n\n      case \"mcp_connection_status\": {\n        this.handleMCPConnectionStatus(parsedEvent);\n        return;\n      }\n\n      case \"agent_tool_request\": {\n        this.handleAgentToolRequest(parsedEvent);\n        return;\n      }\n\n      case \"agent_tool_response\": {\n        this.handleAgentToolResponse(parsedEvent);\n        return;\n      }\n\n      case \"conversation_initiation_metadata\": {\n        this.handleConversationMetadata(parsedEvent);\n        return;\n      }\n\n      case \"asr_initiation_metadata\": {\n        this.handleAsrInitiationMetadata(parsedEvent);\n        return;\n      }\n\n      case \"agent_chat_response_part\": {\n        this.handleAgentChatResponsePart(parsedEvent);\n        return;\n      }\n\n      case \"error\": {\n        this.handleErrorEvent(parsedEvent);\n        return;\n      }\n\n      default: {\n        if (this.options.onDebug) {\n          this.options.onDebug(parsedEvent);\n        }\n        return;\n      }\n    }\n  };\n\n  private onError(message: string, context?: any) {\n    console.error(message, context);\n    if (this.options.onError) {\n      this.options.onError(message, context);\n    }\n  }\n\n  public getId() {\n    return this.connection.conversationId;\n  }\n\n  public isOpen() {\n    return this.status === \"connected\";\n  }\n\n  public setVolume = ({ volume }: { volume: number }) => {\n    this.volume = volume;\n  };\n\n  public setMicMuted(isMuted: boolean) {\n    this.connection.setMicMuted(isMuted);\n  }\n\n  public getInputByteFrequencyData(): Uint8Array {\n    return EMPTY_FREQUENCY_DATA;\n  }\n\n  public getOutputByteFrequencyData(): Uint8Array {\n    return EMPTY_FREQUENCY_DATA;\n  }\n\n  public getInputVolume() {\n    return 0;\n  }\n\n  public getOutputVolume() {\n    return 0;\n  }\n\n  public sendFeedback(like: boolean) {\n    if (!this.canSendFeedback) {\n      console.warn(\n        this.lastFeedbackEventId === 0\n          ? \"Cannot send feedback: the conversation has not started yet.\"\n          : \"Cannot send feedback: feedback has already been sent for the current response.\"\n      );\n      return;\n    }\n\n    this.connection.sendMessage({\n      type: \"feedback\",\n      score: like ? \"like\" : \"dislike\",\n      event_id: this.currentEventId,\n    });\n    this.lastFeedbackEventId = this.currentEventId;\n    this.updateCanSendFeedback();\n  }\n\n  public sendContextualUpdate(text: string) {\n    this.connection.sendMessage({\n      type: \"contextual_update\",\n      text,\n    });\n  }\n\n  public sendUserMessage(text: string) {\n    this.connection.sendMessage({\n      type: \"user_message\",\n      text,\n    });\n  }\n\n  public sendUserActivity() {\n    this.connection.sendMessage({\n      type: \"user_activity\",\n    });\n  }\n\n  public sendMCPToolApprovalResult(toolCallId: string, isApproved: boolean) {\n    this.connection.sendMessage({\n      type: \"mcp_tool_approval_result\",\n      tool_call_id: toolCallId,\n      is_approved: isApproved,\n    });\n  }\n}\n","import type { IncomingSocketEvent, OutgoingSocketEvent } from \"./events\";\nimport type { Mode } from \"../BaseConversation\";\nimport type { ConversationConfigOverrideAgentLanguage as Language } from \"@elevenlabs/types/generated/types/asyncapi-types\";\nimport type { DisconnectionDetails } from \"@elevenlabs/types\";\n\nexport type {\n  DisconnectionDetails,\n  ConversationConfigOverrideAgentLanguage as Language,\n} from \"@elevenlabs/types\";\n\nexport type DelayConfig = {\n  default: number;\n  android?: number;\n  ios?: number;\n};\n\nexport type FormatConfig = {\n  format: \"pcm\" | \"ulaw\";\n  sampleRate: number;\n  outputDeviceId?: string;\n};\n\nexport type OnDisconnectCallback = (details: DisconnectionDetails) => void;\nexport type OnMessageCallback = (event: IncomingSocketEvent) => void;\n\nexport type BaseSessionConfig = {\n  origin?: string;\n  authorization?: string;\n  livekitUrl?: string;\n  overrides?: {\n    agent?: {\n      prompt?: {\n        prompt?: string;\n      };\n      firstMessage?: string;\n      language?: Language;\n    };\n    tts?: {\n      voiceId?: string;\n    };\n    conversation?: {\n      textOnly?: boolean;\n    };\n    client?: {\n      source?: string;\n      version?: string;\n    };\n  };\n  customLlmExtraBody?: unknown;\n  dynamicVariables?: Record<string, string | number | boolean>;\n  useWakeLock?: boolean;\n  connectionDelay?: DelayConfig;\n  textOnly?: boolean;\n  userId?: string;\n};\n\nexport type ConnectionType = \"websocket\" | \"webrtc\";\n\nexport type PublicSessionConfig = BaseSessionConfig & {\n  agentId: string;\n  connectionType: ConnectionType;\n  signedUrl?: never;\n  conversationToken?: never;\n};\n\nexport type PrivateWebSocketSessionConfig = BaseSessionConfig & {\n  signedUrl: string;\n  connectionType?: \"websocket\";\n  agentId?: never;\n  conversationToken?: never;\n};\n\nexport type PrivateWebRTCSessionConfig = BaseSessionConfig & {\n  conversationToken: string;\n  connectionType?: \"webrtc\";\n  agentId?: never;\n  signedUrl?: never;\n};\n\n// Union type for all possible session configurations\nexport type SessionConfig =\n  | PublicSessionConfig\n  | PrivateWebSocketSessionConfig\n  | PrivateWebRTCSessionConfig;\n\nexport abstract class BaseConnection {\n  public abstract readonly conversationId: string;\n  public abstract readonly inputFormat: FormatConfig;\n  public abstract readonly outputFormat: FormatConfig;\n\n  protected queue: IncomingSocketEvent[] = [];\n  protected disconnectionDetails: DisconnectionDetails | null = null;\n  protected onDisconnectCallback: OnDisconnectCallback | null = null;\n  protected onMessageCallback: OnMessageCallback | null = null;\n  protected onModeChangeCallback: ((mode: Mode) => void) | null = null;\n  protected onDebug?: (info: unknown) => void;\n\n  constructor(config: { onDebug?: (info: unknown) => void } = {}) {\n    this.onDebug = config.onDebug;\n  }\n\n  protected debug(info: unknown) {\n    if (this.onDebug) this.onDebug(info);\n  }\n\n  public abstract close(): void;\n  public abstract sendMessage(message: OutgoingSocketEvent): void;\n  public abstract setMicMuted(isMuted: boolean): Promise<void>;\n\n  public onMessage(callback: OnMessageCallback) {\n    this.onMessageCallback = callback;\n    const queue = this.queue;\n    this.queue = [];\n\n    if (queue.length > 0) {\n      // Make sure the queue is flushed after the constructors finishes and\n      // classes are initialized.\n      queueMicrotask(() => {\n        queue.forEach(callback);\n      });\n    }\n  }\n\n  public onDisconnect(callback: OnDisconnectCallback) {\n    this.onDisconnectCallback = callback;\n    const details = this.disconnectionDetails;\n    if (details) {\n      // Make sure the event is triggered after the constructors finishes and\n      // classes are initialized.\n      queueMicrotask(() => {\n        callback(details);\n      });\n    }\n  }\n\n  public onModeChange(callback: (mode: Mode) => void) {\n    this.onModeChangeCallback = callback;\n  }\n\n  protected updateMode(mode: Mode) {\n    this.onModeChangeCallback?.(mode);\n  }\n\n  protected disconnect(details: DisconnectionDetails) {\n    if (!this.disconnectionDetails) {\n      this.disconnectionDetails = details;\n      this.onDisconnectCallback?.(details);\n    }\n  }\n\n  protected handleMessage(parsedEvent: IncomingSocketEvent) {\n    if (this.onMessageCallback) {\n      this.onMessageCallback(parsedEvent);\n    } else {\n      this.queue.push(parsedEvent);\n    }\n  }\n}\n\nexport function parseFormat(format: string): FormatConfig {\n  const [formatPart, sampleRatePart] = format.split(\"_\");\n  if (![\"pcm\", \"ulaw\"].includes(formatPart)) {\n    throw new Error(`Invalid format: ${format}`);\n  }\n\n  const sampleRate = Number.parseInt(sampleRatePart);\n  if (Number.isNaN(sampleRate)) {\n    throw new Error(`Invalid sample rate: ${sampleRatePart}`);\n  }\n\n  return {\n    format: formatPart as FormatConfig[\"format\"],\n    sampleRate,\n  };\n}\n","// This file is auto-generated during build\nexport const PACKAGE_VERSION = \"0.12.0\";\n","import { Outgoing } from \"@elevenlabs/types\";\nimport {\n  AgentChatResponsePartClientEvent,\n  AgentResponse,\n  AgentResponseCorrection,\n  AgentToolResponseClientEvent,\n  AsrInitiationMetadataEvent as AsrMetadataEvent,\n  Audio,\n  AgentToolRequestClientEvent,\n  ClientToolCallMessage,\n  ConversationMetadata,\n  ErrorMessage,\n  Interruption,\n  McpConnectionStatusClientEvent,\n  McpToolCall,\n  Ping,\n  InternalTentativeAgentResponse as TentativeAgentResponseInternal,\n  UserTranscript,\n  VadScore,\n} from \"@elevenlabs/types/generated/types/asyncapi-types\";\n\n// Compatibility layer - incoming events\nexport type UserTranscriptionEvent = UserTranscript;\nexport type AgentResponseEvent = AgentResponse;\nexport type AgentAudioEvent = Audio;\nexport type InterruptionEvent = Interruption;\nexport type InternalTentativeAgentResponseEvent =\n  TentativeAgentResponseInternal;\nexport type ConfigEvent = ConversationMetadata;\nexport type PingEvent = Ping;\nexport type ClientToolCallEvent = ClientToolCallMessage;\nexport type VadScoreEvent = VadScore;\nexport type MCPToolCallClientEvent = McpToolCall;\nexport type AgentResponseCorrectionEvent = AgentResponseCorrection;\nexport type AgentToolRequestEvent = AgentToolRequestClientEvent;\nexport type AgentToolResponseEvent = AgentToolResponseClientEvent;\nexport type ConversationMetadataEvent = ConversationMetadata;\nexport type AsrInitiationMetadataEvent = AsrMetadataEvent;\nexport type MCPConnectionStatusEvent = McpConnectionStatusClientEvent;\nexport type AgentChatResponsePartEvent = AgentChatResponsePartClientEvent;\nexport type ErrorMessageEvent = ErrorMessage;\n\nexport type IncomingSocketEvent =\n  | UserTranscriptionEvent\n  | AgentResponseEvent\n  | AgentResponseCorrectionEvent\n  | AgentAudioEvent\n  | InterruptionEvent\n  | InternalTentativeAgentResponseEvent\n  | ConfigEvent\n  | PingEvent\n  | ClientToolCallEvent\n  | VadScoreEvent\n  | MCPToolCallClientEvent\n  | AgentToolRequestEvent\n  | AgentToolResponseEvent\n  | ConversationMetadataEvent\n  | AsrInitiationMetadataEvent\n  | MCPConnectionStatusEvent\n  | AgentChatResponsePartEvent\n  | ErrorMessageEvent;\n\n// Compatibility layer - outgoing events\nexport type PongEvent = Outgoing.PongClientToOrchestratorEvent;\nexport type UserAudioEvent = Outgoing.UserAudio;\nexport type UserFeedbackEvent = Outgoing.UserFeedbackClientToOrchestratorEvent;\nexport type ClientToolResultEvent =\n  Outgoing.ClientToolResultClientToOrchestratorEvent;\nexport type InitiationClientDataEvent =\n  Outgoing.ConversationInitiationClientToOrchestratorEvent;\nexport type ContextualUpdateEvent =\n  Outgoing.ContextualUpdateClientToOrchestratorEvent;\nexport type UserMessageEvent = Outgoing.UserMessageClientToOrchestratorEvent;\nexport type UserActivityEvent = Outgoing.UserActivityClientToOrchestratorEvent;\nexport type MCPToolApprovalResultEvent =\n  Outgoing.McpToolApprovalResultClientToOrchestratorEvent;\n\nexport type OutgoingSocketEvent =\n  | PongEvent\n  | UserAudioEvent\n  | InitiationClientDataEvent\n  | UserFeedbackEvent\n  | ClientToolResultEvent\n  | ContextualUpdateEvent\n  | UserMessageEvent\n  | UserActivityEvent\n  | MCPToolApprovalResultEvent;\n\nexport function isValidSocketEvent(event: any): event is IncomingSocketEvent {\n  return !!event.type;\n}\n","import type { SessionConfig } from \"./BaseConnection\";\nimport type { InitiationClientDataEvent } from \"./events\";\n\nexport const CONVERSATION_INITIATION_CLIENT_DATA_TYPE =\n  \"conversation_initiation_client_data\";\n\nexport function constructOverrides(\n  config: SessionConfig\n): InitiationClientDataEvent {\n  const overridesEvent: InitiationClientDataEvent = {\n    type: CONVERSATION_INITIATION_CLIENT_DATA_TYPE,\n  };\n\n  if (config.overrides) {\n    overridesEvent.conversation_config_override = {\n      agent: {\n        prompt: config.overrides.agent?.prompt,\n        first_message: config.overrides.agent?.firstMessage,\n        language: config.overrides.agent?.language,\n      },\n      tts: {\n        voice_id: config.overrides.tts?.voiceId,\n      },\n      conversation: {\n        text_only: config.overrides.conversation?.textOnly,\n      },\n    };\n  }\n\n  if (config.customLlmExtraBody) {\n    overridesEvent.custom_llm_extra_body = config.customLlmExtraBody;\n  }\n\n  if (config.dynamicVariables) {\n    overridesEvent.dynamic_variables = config.dynamicVariables;\n  }\n\n  if (config.userId) {\n    overridesEvent.user_id = config.userId;\n  }\n\n  if (config.overrides?.client) {\n    overridesEvent.source_info = {\n      source: config.overrides.client.source,\n      version: config.overrides.client.version,\n    };\n  }\n\n  return overridesEvent;\n}\n","import {\n  BaseConnection,\n  type SessionConfig,\n  type FormatConfig,\n  parseFormat,\n} from \"./BaseConnection\";\nimport { PACKAGE_VERSION } from \"../version\";\nimport {\n  type ConfigEvent,\n  isValidSocketEvent,\n  type OutgoingSocketEvent,\n} from \"./events\";\nimport { constructOverrides } from \"./overrides\";\n\nconst MAIN_PROTOCOL = \"convai\";\nconst WSS_API_ORIGIN = \"wss://api.elevenlabs.io\";\nconst WSS_API_PATHNAME = \"/v1/convai/conversation?agent_id=\";\n\nexport class WebSocketConnection extends BaseConnection {\n  public readonly conversationId: string;\n  public readonly inputFormat: FormatConfig;\n  public readonly outputFormat: FormatConfig;\n\n  private constructor(\n    private readonly socket: WebSocket,\n    conversationId: string,\n    inputFormat: FormatConfig,\n    outputFormat: FormatConfig\n  ) {\n    super();\n    this.conversationId = conversationId;\n    this.inputFormat = inputFormat;\n    this.outputFormat = outputFormat;\n\n    this.socket.addEventListener(\"error\", event => {\n      // In case the error event is followed by a close event, we want the\n      // latter to be the one that disconnects the session as it contains more\n      // useful information.\n      setTimeout(\n        () =>\n          this.disconnect({\n            reason: \"error\",\n            message: \"The connection was closed due to a socket error.\",\n            context: event,\n          }),\n        0\n      );\n    });\n\n    this.socket.addEventListener(\"close\", event => {\n      this.disconnect(\n        event.code === 1000\n          ? {\n              reason: \"agent\",\n              context: event,\n            }\n          : {\n              reason: \"error\",\n              message:\n                event.reason || \"The connection was closed by the server.\",\n              context: event,\n            }\n      );\n    });\n\n    this.socket.addEventListener(\"message\", event => {\n      try {\n        const parsedEvent = JSON.parse(event.data);\n        if (!isValidSocketEvent(parsedEvent)) {\n          this.debug({\n            type: \"invalid_event\",\n            message: \"Received invalid socket event\",\n            data: event.data,\n          });\n          return;\n        }\n        this.handleMessage(parsedEvent);\n      } catch (error) {\n        this.debug({\n          type: \"parsing_error\",\n          message: \"Failed to parse socket message\",\n          error: error instanceof Error ? error.message : String(error),\n          data: event.data,\n        });\n      }\n    });\n  }\n\n  public static async create(\n    config: SessionConfig\n  ): Promise<WebSocketConnection> {\n    let socket: WebSocket | null = null;\n\n    try {\n      const origin = config.origin ?? WSS_API_ORIGIN;\n      let url: string;\n\n      const version = config.overrides?.client?.version || PACKAGE_VERSION;\n      const source = config.overrides?.client?.source || \"js_sdk\";\n\n      if (config.signedUrl) {\n        const separator = config.signedUrl.includes(\"?\") ? \"&\" : \"?\";\n        url = `${config.signedUrl}${separator}source=${source}&version=${version}`;\n      } else {\n        url = `${origin}${WSS_API_PATHNAME}${config.agentId}&source=${source}&version=${version}`;\n      }\n\n      const protocols = [MAIN_PROTOCOL];\n      if (config.authorization) {\n        protocols.push(`bearer.${config.authorization}`);\n      }\n      socket = new WebSocket(url, protocols);\n\n      const conversationConfig = await new Promise<\n        ConfigEvent[\"conversation_initiation_metadata_event\"]\n      >((resolve, reject) => {\n        socket!.addEventListener(\n          \"open\",\n          () => {\n            const overridesEvent = constructOverrides(config);\n\n            socket?.send(JSON.stringify(overridesEvent));\n          },\n          { once: true }\n        );\n\n        socket!.addEventListener(\"error\", event => {\n          // In case the error event is followed by a close event, we want the\n          // latter to be the one that rejects the promise as it contains more\n          // useful information.\n          setTimeout(() => reject(event), 0);\n        });\n\n        socket!.addEventListener(\"close\", reject);\n\n        socket!.addEventListener(\n          \"message\",\n          (event: MessageEvent) => {\n            const message = JSON.parse(event.data);\n\n            if (!isValidSocketEvent(message)) {\n              return;\n            }\n\n            if (message.type === \"conversation_initiation_metadata\") {\n              resolve(message.conversation_initiation_metadata_event);\n            } else {\n              console.warn(\n                \"First received message is not conversation metadata.\"\n              );\n            }\n          },\n          { once: true }\n        );\n      });\n\n      const {\n        conversation_id,\n        agent_output_audio_format,\n        user_input_audio_format,\n      } = conversationConfig;\n\n      const inputFormat = parseFormat(user_input_audio_format ?? \"pcm_16000\");\n      const outputFormat = parseFormat(agent_output_audio_format);\n\n      return new WebSocketConnection(\n        socket,\n        conversation_id,\n        inputFormat,\n        outputFormat\n      );\n    } catch (error) {\n      socket?.close();\n      throw error;\n    }\n  }\n\n  public close() {\n    this.socket.close();\n  }\n\n  public sendMessage(message: OutgoingSocketEvent) {\n    this.socket.send(JSON.stringify(message));\n  }\n\n  public async setMicMuted(isMuted: boolean): Promise<void> {\n    console.warn(\n      `WebSocket connection setMicMuted called with ${isMuted}, but this is handled by VoiceConversation`\n    );\n  }\n}\n","export function arrayBufferToBase64(b: ArrayBufferLike) {\n  const buffer = new Uint8Array(b);\n  // @ts-ignore\n  const base64Data = window.btoa(String.fromCharCode(...buffer));\n  return base64Data;\n}\n\nexport function base64ToArrayBuffer(base64: string): ArrayBuffer {\n  const binaryString = window.atob(base64);\n  const len = binaryString.length;\n  const bytes = new Uint8Array(len);\n  for (let i = 0; i < len; i++) {\n    bytes[i] = binaryString.charCodeAt(i);\n  }\n  return bytes.buffer;\n}\n","const URLCache = new Map<string, string>();\n\nexport function createWorkletModuleLoader(name: string, sourceCode: string) {\n  return async (worklet: AudioWorklet, path?: string) => {\n    const cachedUrl = URLCache.get(name);\n    if (cachedUrl) {\n      return worklet.addModule(cachedUrl);\n    }\n\n    // If a path is provided, use it directly (CSP-friendly approach)\n    if (path) {\n      try {\n        await worklet.addModule(path);\n        URLCache.set(name, path);\n        return;\n      } catch (error) {\n        throw new Error(\n          `Failed to load the ${name} worklet module from path: ${path}. Error: ${error}`\n        );\n      }\n    }\n\n    const blob = new Blob([sourceCode], { type: \"application/javascript\" });\n    const blobURL = URL.createObjectURL(blob);\n    try {\n      await worklet.addModule(blobURL);\n      URLCache.set(name, blobURL);\n      return;\n    } catch {\n      URL.revokeObjectURL(blobURL);\n    }\n\n    try {\n      // Attempting to start a conversation in Safari inside an iframe will\n      // throw a CORS error because the blob:// protocol is considered\n      // cross-origin. In such cases, fall back to using a base64 data URL:\n      const base64 = btoa(sourceCode);\n      const moduleURL = `data:application/javascript;base64,${base64}`;\n      await worklet.addModule(moduleURL);\n      URLCache.set(name, moduleURL);\n    } catch (error) {\n      throw new Error(\n        `Failed to load the ${name} worklet module. Make sure the browser supports AudioWorklets. If you are using a strict CSP, you may need to self-host the worklet files.`\n      );\n    }\n  };\n}\n","// AUTO-GENERATED BY packages/client/scripts/generateWorklets.js\nimport { createWorkletModuleLoader } from \"./createWorkletModuleLoader\";\n\nexport const loadRawAudioProcessor = createWorkletModuleLoader(\n  \"rawAudioProcessor\",\n  // language=JavaScript\n  `/*\n * ulaw encoding logic taken from the wavefile library\n * https://github.com/rochars/wavefile/blob/master/lib/codecs/mulaw.js\n * USED BY @elevenlabs/client\n */\n\nconst BIAS = 0x84;\nconst CLIP = 32635;\nconst encodeTable = [\n  0,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,\n  4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,\n  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7\n];\n\nfunction encodeSample(sample) {\n  let sign;\n  let exponent;\n  let mantissa;\n  let muLawSample;\n  sign = (sample >> 8) & 0x80;\n  if (sign !== 0) sample = -sample;\n  sample = sample + BIAS;\n  if (sample > CLIP) sample = CLIP;\n  exponent = encodeTable[(sample>>7) & 0xFF];\n  mantissa = (sample >> (exponent+3)) & 0x0F;\n  muLawSample = ~(sign | (exponent << 4) | mantissa);\n  \n  return muLawSample;\n}\n\nclass RawAudioProcessor extends AudioWorkletProcessor {\n  constructor() {\n    super();\n              \n    this.port.onmessage = ({ data }) => {\n      switch (data.type) {\n        case \"setFormat\":\n          this.isMuted = false;\n          this.buffer = []; // Initialize an empty buffer\n          this.bufferSize = data.sampleRate / 4;\n          this.format = data.format;\n\n          if (globalThis.LibSampleRate && sampleRate !== data.sampleRate) {\n            globalThis.LibSampleRate.create(1, sampleRate, data.sampleRate).then(resampler => {\n              this.resampler = resampler;\n            });\n          }\n          break;\n        case \"setMuted\":\n          this.isMuted = data.isMuted;\n          break;\n      }\n    };\n  }\n  process(inputs) {\n    if (!this.buffer) {\n      return true;\n    }\n    \n    const input = inputs[0]; // Get the first input node\n    if (input.length > 0) {\n      let channelData = input[0]; // Get the first channel's data\n\n      // Resample the audio if necessary\n      if (this.resampler) {\n        channelData = this.resampler.full(channelData);\n      }\n\n      // Add channel data to the buffer\n      this.buffer.push(...channelData);\n      // Get max volume \n      let sum = 0.0;\n      for (let i = 0; i < channelData.length; i++) {\n        sum += channelData[i] * channelData[i];\n      }\n      const maxVolume = Math.sqrt(sum / channelData.length);\n      // Check if buffer size has reached or exceeded the threshold\n      if (this.buffer.length >= this.bufferSize) {\n        const float32Array = this.isMuted \n          ? new Float32Array(this.buffer.length)\n          : new Float32Array(this.buffer);\n\n        let encodedArray = this.format === \"ulaw\"\n          ? new Uint8Array(float32Array.length)\n          : new Int16Array(float32Array.length);\n\n        // Iterate through the Float32Array and convert each sample to PCM16\n        for (let i = 0; i < float32Array.length; i++) {\n          // Clamp the value to the range [-1, 1]\n          let sample = Math.max(-1, Math.min(1, float32Array[i]));\n\n          // Scale the sample to the range [-32768, 32767]\n          let value = sample < 0 ? sample * 32768 : sample * 32767;\n          if (this.format === \"ulaw\") {\n            value = encodeSample(Math.round(value));\n          }\n\n          encodedArray[i] = value;\n        }\n\n        // Send the buffered data to the main script\n        this.port.postMessage([encodedArray, maxVolume]);\n\n        // Clear the buffer after sending\n        this.buffer = [];\n      }\n    }\n    return true; // Continue processing\n  }\n}\nregisterProcessor(\"rawAudioProcessor\", RawAudioProcessor);\n`\n);\n","import {\n  BaseConnection,\n  type SessionConfig,\n  type FormatConfig,\n  parseFormat,\n} from \"./BaseConnection\";\nimport { PACKAGE_VERSION } from \"../version\";\nimport { isValidSocketEvent, type OutgoingSocketEvent } from \"./events\";\nimport {\n  Room,\n  RoomEvent,\n  Track,\n  ConnectionState,\n  createLocalAudioTrack,\n} from \"livekit-client\";\nimport type {\n  RemoteAudioTrack,\n  Participant,\n  TrackPublication,\n  RemoteParticipant,\n} from \"livekit-client\";\nimport {\n  constructOverrides,\n  CONVERSATION_INITIATION_CLIENT_DATA_TYPE,\n} from \"./overrides\";\nimport { arrayBufferToBase64 } from \"./audio\";\nimport { loadRawAudioProcessor } from \"./rawAudioProcessor.generated\";\n\nconst DEFAULT_LIVEKIT_WS_URL = \"wss://livekit.rtc.elevenlabs.io\";\nconst HTTPS_API_ORIGIN = \"https://api.elevenlabs.io\";\n\n// Convert WSS origin to HTTPS for API calls\nfunction convertWssToHttps(origin: string): string {\n  return origin.replace(/^wss:\\/\\//, \"https://\");\n}\n\nexport type ConnectionConfig = SessionConfig & {\n  onDebug?: (info: unknown) => void;\n};\n\nexport class WebRTCConnection extends BaseConnection {\n  public conversationId: string;\n  public readonly inputFormat: FormatConfig;\n  public readonly outputFormat: FormatConfig;\n\n  private room: Room;\n  private isConnected = false;\n  private audioEventId = 1;\n  private audioCaptureContext: AudioContext | null = null;\n  private audioElements: HTMLAudioElement[] = [];\n  private outputDeviceId: string | null = null;\n\n  private outputAnalyser: AnalyserNode | null = null;\n  private outputFrequencyData: Uint8Array<ArrayBuffer> | null = null;\n\n  private constructor(\n    room: Room,\n    conversationId: string,\n    inputFormat: FormatConfig,\n    outputFormat: FormatConfig,\n    config: { onDebug?: (info: unknown) => void } = {}\n  ) {\n    super(config);\n    this.room = room;\n    this.conversationId = conversationId;\n    this.inputFormat = inputFormat;\n    this.outputFormat = outputFormat;\n\n    this.setupRoomEventListeners();\n  }\n\n  public static async create(\n    config: ConnectionConfig\n  ): Promise<WebRTCConnection> {\n    let conversationToken: string;\n\n    // Handle different authentication scenarios\n    if (\"conversationToken\" in config && config.conversationToken) {\n      // Direct token provided\n      conversationToken = config.conversationToken;\n    } else if (\"agentId\" in config && config.agentId) {\n      // Agent ID provided - fetch token from API\n      try {\n        const version = config.overrides?.client?.version || PACKAGE_VERSION;\n        const source = config.overrides?.client?.source || \"js_sdk\";\n        const configOrigin = config.origin ?? HTTPS_API_ORIGIN;\n        const origin = convertWssToHttps(configOrigin); //origin is wss, not https\n        const url = `${origin}/v1/convai/conversation/token?agent_id=${config.agentId}&source=${source}&version=${version}`;\n        const response = await fetch(url);\n\n        if (!response.ok) {\n          throw new Error(\n            `ElevenLabs API returned ${response.status} ${response.statusText}`\n          );\n        }\n\n        const data = await response.json();\n        conversationToken = data.token;\n\n        if (!conversationToken) {\n          throw new Error(\"No conversation token received from API\");\n        }\n      } catch (error) {\n        let msg = error instanceof Error ? error.message : String(error);\n        if (error instanceof Error && error.message.includes(\"401\")) {\n          msg =\n            \"Your agent has authentication enabled, but no signed URL or conversation token was provided.\";\n        }\n\n        throw new Error(\n          `Failed to fetch conversation token for agent ${config.agentId}: ${msg}`\n        );\n      }\n    } else {\n      throw new Error(\n        \"Either conversationToken or agentId is required for WebRTC connection\"\n      );\n    }\n\n    const room = new Room();\n\n    try {\n      // Create connection instance first to set up event listeners\n      const conversationId = `room_${Date.now()}`;\n      const inputFormat = parseFormat(\"pcm_48000\");\n      const outputFormat = parseFormat(\"pcm_48000\");\n      const connection = new WebRTCConnection(\n        room,\n        conversationId,\n        inputFormat,\n        outputFormat,\n        config\n      );\n\n      // Use configurable LiveKit URL or default if not provided\n      const livekitUrl = config.livekitUrl || DEFAULT_LIVEKIT_WS_URL;\n\n      // Connect to the LiveKit room and wait for the Connected event\n      await room.connect(livekitUrl, conversationToken);\n\n      // Wait for the Connected event to ensure isConnected is true\n      await new Promise<void>(resolve => {\n        if (connection.isConnected) {\n          resolve();\n        } else {\n          const onConnected = () => {\n            room.off(RoomEvent.Connected, onConnected);\n            resolve();\n          };\n          room.on(RoomEvent.Connected, onConnected);\n        }\n      });\n\n      if (room.name) {\n        connection.conversationId =\n          room.name.match(/(conv_[a-zA-Z0-9]+)/)?.[0] || room.name;\n      }\n\n      // Enable microphone and send overrides\n      await room.localParticipant.setMicrophoneEnabled(true);\n\n      const overridesEvent = constructOverrides(config);\n\n      connection.debug({\n        type: CONVERSATION_INITIATION_CLIENT_DATA_TYPE,\n        message: overridesEvent,\n      });\n\n      await connection.sendMessage(overridesEvent);\n\n      return connection;\n    } catch (error) {\n      await room.disconnect();\n      throw error;\n    }\n  }\n\n  private setupRoomEventListeners() {\n    this.room.on(RoomEvent.Connected, async () => {\n      this.isConnected = true;\n      console.info(\"WebRTC room connected\");\n    });\n\n    this.room.on(RoomEvent.Disconnected, reason => {\n      this.isConnected = false;\n      this.disconnect({\n        reason: \"agent\",\n        context: new CloseEvent(\"close\", { reason: reason?.toString() }),\n      });\n    });\n\n    this.room.on(RoomEvent.ConnectionStateChanged, state => {\n      if (state === ConnectionState.Disconnected) {\n        this.isConnected = false;\n        this.disconnect({\n          reason: \"error\",\n          message: `LiveKit connection state changed to ${state}`,\n          context: new Event(\"connection_state_changed\"),\n        });\n      }\n    });\n\n    // Handle incoming data messages\n    this.room.on(\n      RoomEvent.DataReceived,\n      (payload: Uint8Array, _participant) => {\n        try {\n          const message = JSON.parse(new TextDecoder().decode(payload));\n\n          // Filter out audio messages for WebRTC - they're handled via audio tracks\n          if (message.type === \"audio\") {\n            return;\n          }\n\n          if (isValidSocketEvent(message)) {\n            this.handleMessage(message);\n          } else {\n            console.warn(\"Invalid socket event received:\", message);\n          }\n        } catch (error) {\n          console.warn(\"Failed to parse incoming data message:\", error);\n          console.warn(\"Raw payload:\", new TextDecoder().decode(payload));\n        }\n      }\n    );\n\n    this.room.on(\n      RoomEvent.TrackSubscribed,\n      async (\n        track: Track,\n        _publication: TrackPublication,\n        participant: Participant\n      ) => {\n        if (\n          track.kind === Track.Kind.Audio &&\n          participant.identity.includes(\"agent\")\n        ) {\n          // Play the audio track\n          const remoteAudioTrack = track as RemoteAudioTrack;\n          const audioElement = remoteAudioTrack.attach();\n          audioElement.autoplay = true;\n          audioElement.controls = false;\n\n          // Set output device if one was previously selected\n          if (this.outputDeviceId && audioElement.setSinkId) {\n            try {\n              await audioElement.setSinkId(this.outputDeviceId);\n            } catch (error) {\n              console.warn(\n                \"Failed to set output device for new audio element:\",\n                error\n              );\n            }\n          }\n\n          // Add to DOM (hidden) to ensure it plays\n          audioElement.style.display = \"none\";\n          document.body.appendChild(audioElement);\n\n          // Store reference for volume control\n          this.audioElements.push(audioElement);\n\n          // Apply current volume if it exists (for when volume was set before audio track arrived)\n          if (this.audioElements.length === 1) {\n            // First audio element - trigger a callback to sync with current volume\n            this.onDebug?.({ type: \"audio_element_ready\" });\n          }\n\n          // Set up audio capture for onAudio callback\n          await this.setupAudioCapture(remoteAudioTrack);\n        }\n      }\n    );\n\n    this.room.on(\n      RoomEvent.ActiveSpeakersChanged,\n      async (speakers: Participant[]) => {\n        if (speakers.length > 0) {\n          this.updateMode(\n            speakers[0].identity.startsWith(\"agent\") ? \"speaking\" : \"listening\"\n          );\n        } else {\n          this.updateMode(\"listening\");\n        }\n      }\n    );\n\n    this.room.on(\n      RoomEvent.ParticipantDisconnected,\n      (participant: RemoteParticipant) => {\n        if (participant.identity?.startsWith(\"agent\")) {\n          this.disconnect({\n            reason: \"agent\",\n            context: new CloseEvent(\"close\", { reason: \"agent disconnected\" }),\n          });\n        }\n      }\n    );\n  }\n\n  public close() {\n    if (this.isConnected) {\n      try {\n        // Explicitly stop all local tracks before disconnecting to ensure microphone is released\n        this.room.localParticipant.audioTrackPublications.forEach(\n          publication => {\n            if (publication.track) {\n              publication.track.stop();\n            }\n          }\n        );\n      } catch (error) {\n        console.warn(\"Error stopping local tracks:\", error);\n      }\n\n      // Clean up audio capture context (non-blocking)\n      if (this.audioCaptureContext) {\n        this.audioCaptureContext.close().catch(error => {\n          console.warn(\"Error closing audio capture context:\", error);\n        });\n        this.audioCaptureContext = null;\n      }\n\n      // Clean up audio elements\n      this.audioElements.forEach(element => {\n        if (element.parentNode) {\n          element.parentNode.removeChild(element);\n        }\n      });\n      this.audioElements = [];\n\n      this.room.disconnect();\n    }\n  }\n\n  public async sendMessage(message: OutgoingSocketEvent) {\n    if (!this.isConnected || !this.room.localParticipant) {\n      console.warn(\n        \"Cannot send message: room not connected or no local participant\"\n      );\n      return;\n    }\n\n    // In WebRTC mode, audio is sent via published tracks, not data messages\n    if (\"user_audio_chunk\" in message) {\n      // Ignore audio data messages - audio flows through WebRTC tracks\n      return;\n    }\n\n    try {\n      const encoder = new TextEncoder();\n      const data = encoder.encode(JSON.stringify(message));\n\n      await this.room.localParticipant.publishData(data, { reliable: true });\n    } catch (error) {\n      this.debug({\n        type: \"send_message_error\",\n        message: {\n          message,\n          error,\n        },\n      });\n      console.error(\"Failed to send message via WebRTC:\", error);\n    }\n  }\n\n  // Get the room instance for advanced usage\n  public getRoom(): Room {\n    return this.room;\n  }\n\n  public async setMicMuted(isMuted: boolean): Promise<void> {\n    if (!this.isConnected || !this.room.localParticipant) {\n      console.warn(\n        \"Cannot set microphone muted: room not connected or no local participant\"\n      );\n      return;\n    }\n\n    // Get the microphone track publication\n    const micTrackPublication = this.room.localParticipant.getTrackPublication(\n      Track.Source.Microphone\n    );\n\n    if (micTrackPublication?.track) {\n      try {\n        // Use LiveKit's built-in track muting\n        if (isMuted) {\n          await micTrackPublication.track.mute();\n        } else {\n          await micTrackPublication.track.unmute();\n        }\n      } catch (_error) {\n        // If track muting fails, fall back to participant-level control\n        await this.room.localParticipant.setMicrophoneEnabled(!isMuted);\n      }\n    } else {\n      // No track found, use participant-level control directly\n      await this.room.localParticipant.setMicrophoneEnabled(!isMuted);\n    }\n  }\n\n  private async setupAudioCapture(track: RemoteAudioTrack) {\n    try {\n      // Create audio context for processing\n      const audioContext = new AudioContext();\n      this.audioCaptureContext = audioContext;\n\n      // Create analyser for frequency data\n      this.outputAnalyser = audioContext.createAnalyser();\n      this.outputAnalyser.fftSize = 2048;\n      this.outputAnalyser.smoothingTimeConstant = 0.8;\n\n      // Create MediaStream from the track\n      const mediaStream = new MediaStream([track.mediaStreamTrack]);\n\n      // Create audio source from the stream\n      const source = audioContext.createMediaStreamSource(mediaStream);\n\n      // Connect source to analyser\n      source.connect(this.outputAnalyser);\n\n      await loadRawAudioProcessor(audioContext.audioWorklet);\n      const worklet = new AudioWorkletNode(audioContext, \"rawAudioProcessor\");\n\n      // Connect analyser to worklet for processing\n      this.outputAnalyser.connect(worklet);\n\n      // Configure the processor for the output format\n      worklet.port.postMessage({\n        type: \"setFormat\",\n        format: this.outputFormat.format,\n        sampleRate: this.outputFormat.sampleRate,\n      });\n\n      // Handle processed audio data\n      worklet.port.onmessage = (event: MessageEvent) => {\n        const [audioData, maxVolume] = event.data;\n\n        // Only send audio if there's significant volume (not just silence)\n        const volumeThreshold = 0.01;\n\n        if (maxVolume > volumeThreshold) {\n          // Convert to base64\n          const base64Audio = arrayBufferToBase64(audioData.buffer);\n\n          // Use sequential event ID for proper feedback tracking\n          const eventId = this.audioEventId++;\n\n          // Trigger the onAudio callback by simulating an audio event\n          this.handleMessage({\n            type: \"audio\",\n            audio_event: {\n              audio_base_64: base64Audio,\n              event_id: eventId,\n            },\n          });\n        }\n      };\n\n      // Connect the audio processing chain\n      source.connect(worklet);\n    } catch (error) {\n      console.warn(\"Failed to set up audio capture:\", error);\n    }\n  }\n\n  public setAudioVolume(volume: number) {\n    this.audioElements.forEach(element => {\n      element.volume = volume;\n    });\n  }\n\n  public async setAudioOutputDevice(deviceId: string): Promise<void> {\n    if (!(\"setSinkId\" in HTMLAudioElement.prototype)) {\n      throw new Error(\"setSinkId is not supported in this browser\");\n    }\n\n    // Set output device for all existing audio elements\n    const promises = this.audioElements.map(async element => {\n      try {\n        await element.setSinkId(deviceId);\n      } catch (error) {\n        console.error(\"Failed to set sink ID for audio element:\", error);\n        throw error;\n      }\n    });\n\n    await Promise.all(promises);\n\n    // Store the device ID for future audio elements\n    this.outputDeviceId = deviceId;\n  }\n\n  public async setAudioInputDevice(deviceId: string): Promise<void> {\n    if (!this.isConnected || !this.room.localParticipant) {\n      throw new Error(\n        \"Cannot change input device: room not connected or no local participant\"\n      );\n    }\n\n    try {\n      // Get the current microphone track publication\n      const currentMicTrackPublication =\n        this.room.localParticipant.getTrackPublication(Track.Source.Microphone);\n\n      // Stop the current microphone track if it exists\n      if (currentMicTrackPublication?.track) {\n        await currentMicTrackPublication.track.stop();\n        await this.room.localParticipant.unpublishTrack(\n          currentMicTrackPublication.track\n        );\n      }\n\n      // Create constraints for the new input device\n      const audioConstraints: MediaTrackConstraints = {\n        deviceId: { exact: deviceId },\n        echoCancellation: true,\n        noiseSuppression: true,\n        autoGainControl: true,\n        channelCount: { ideal: 1 },\n      };\n\n      // Create new audio track with the specified device\n      const audioTrack = await createLocalAudioTrack(audioConstraints);\n\n      // Publish the new microphone track\n      await this.room.localParticipant.publishTrack(audioTrack, {\n        name: \"microphone\",\n        source: Track.Source.Microphone,\n      });\n    } catch (error) {\n      console.error(\"Failed to change input device:\", error);\n\n      // Try to re-enable default microphone on failure\n      try {\n        await this.room.localParticipant.setMicrophoneEnabled(true);\n      } catch (recoveryError) {\n        console.error(\n          \"Failed to recover microphone after device switch error:\",\n          recoveryError\n        );\n      }\n\n      throw error;\n    }\n  }\n\n  public getOutputByteFrequencyData(): Uint8Array<ArrayBuffer> | null {\n    if (!this.outputAnalyser) return null;\n\n    this.outputFrequencyData ??= new Uint8Array(\n      this.outputAnalyser.frequencyBinCount\n    ) as Uint8Array<ArrayBuffer>;\n    this.outputAnalyser.getByteFrequencyData(this.outputFrequencyData);\n    return this.outputFrequencyData;\n  }\n}\n","import type {\n  BaseConnection,\n  SessionConfig,\n  ConnectionType,\n} from \"./BaseConnection\";\nimport { WebSocketConnection } from \"./WebSocketConnection\";\nimport { WebRTCConnection } from \"./WebRTCConnection\";\n\nfunction determineConnectionType(config: SessionConfig): ConnectionType {\n  // If connectionType is explicitly specified, use it\n  if (config.connectionType) {\n    return config.connectionType;\n  }\n\n  // If conversationToken is provided, use WebRTC\n  if (\"conversationToken\" in config && config.conversationToken) {\n    return \"webrtc\";\n  }\n\n  // Default to WebSocket for backward compatibility\n  return \"websocket\";\n}\n\nexport async function createConnection(\n  config: SessionConfig\n): Promise<BaseConnection> {\n  const connectionType = determineConnectionType(config);\n\n  switch (connectionType) {\n    case \"websocket\":\n      return WebSocketConnection.create(config);\n    case \"webrtc\":\n      return WebRTCConnection.create(config);\n    default:\n      throw new Error(`Unknown connection type: ${connectionType}`);\n  }\n}\n","export function isIosDevice() {\n  return (\n    [\n      \"iPad Simulator\",\n      \"iPhone Simulator\",\n      \"iPod Simulator\",\n      \"iPad\",\n      \"iPhone\",\n      \"iPod\",\n    ].includes(navigator.platform) ||\n    // iPad on iOS 13 detection\n    (navigator.userAgent.includes(\"Mac\") && \"ontouchend\" in document)\n  );\n}\n\nexport function isAndroidDevice() {\n  return /android/i.test(navigator.userAgent);\n}\n","import { isAndroidDevice, isIosDevice } from \"./compatibility\";\nimport type { DelayConfig } from \"./connection\";\n\nexport async function applyDelay(\n  delayConfig: DelayConfig = {\n    default: 0,\n    // Give the Android AudioManager enough time to switch to the correct audio mode\n    android: 3_000,\n  }\n) {\n  let delay = delayConfig.default;\n  if (isAndroidDevice()) {\n    delay = delayConfig.android ?? delay;\n  } else if (isIosDevice()) {\n    delay = delayConfig.ios ?? delay;\n  }\n\n  if (delay > 0) {\n    await new Promise(resolve => setTimeout(resolve, delay));\n  }\n}\n","import { createConnection } from \"./utils/ConnectionFactory\";\nimport type { BaseConnection } from \"./utils/BaseConnection\";\nimport { applyDelay } from \"./utils/applyDelay\";\nimport { BaseConversation, type PartialOptions } from \"./BaseConversation\";\n\nexport class TextConversation extends BaseConversation {\n  public static async startSession(\n    options: PartialOptions\n  ): Promise<TextConversation> {\n    const fullOptions = BaseConversation.getFullOptions(options);\n\n    if (fullOptions.onStatusChange) {\n      fullOptions.onStatusChange({ status: \"connecting\" });\n    }\n    if (fullOptions.onCanSendFeedbackChange) {\n      fullOptions.onCanSendFeedbackChange({ canSendFeedback: false });\n    }\n    if (fullOptions.onModeChange) {\n      fullOptions.onModeChange({ mode: \"listening\" });\n    }\n    if (fullOptions.onCanSendFeedbackChange) {\n      fullOptions.onCanSendFeedbackChange({ canSendFeedback: false });\n    }\n\n    let connection: BaseConnection | null = null;\n    try {\n      await applyDelay(fullOptions.connectionDelay);\n      connection = await createConnection(options);\n      return new TextConversation(fullOptions, connection);\n    } catch (error) {\n      if (fullOptions.onStatusChange) {\n        fullOptions.onStatusChange({ status: \"disconnected\" });\n      }\n      connection?.close();\n      throw error;\n    }\n  }\n}\n","import { loadRawAudioProcessor } from \"./rawAudioProcessor.generated\";\nimport type { FormatConfig } from \"./connection\";\nimport { isIosDevice } from \"./compatibility\";\nimport type { AudioWorkletConfig } from \"../BaseConversation\";\n\nexport type InputConfig = {\n  preferHeadphonesForIosDevices?: boolean;\n  inputDeviceId?: string;\n};\n\nconst LIBSAMPLERATE_JS =\n  \"https://cdn.jsdelivr.net/npm/@alexanderolsen/libsamplerate-js@2.1.2/dist/libsamplerate.worklet.js\";\n\nconst defaultConstraints = {\n  echoCancellation: true,\n  noiseSuppression: true,\n  // Automatic gain control helps maintain a steady volume level with microphones: https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackSettings/autoGainControl\n  autoGainControl: true,\n  // Mono audio for better echo cancellation\n  channelCount: { ideal: 1 },\n};\n\nexport class Input {\n  public static async create({\n    sampleRate,\n    format,\n    preferHeadphonesForIosDevices,\n    inputDeviceId,\n    workletPaths,\n    libsampleratePath,\n  }: FormatConfig & InputConfig & AudioWorkletConfig): Promise<Input> {\n    let context: AudioContext | null = null;\n    let inputStream: MediaStream | null = null;\n\n    try {\n      const options: MediaTrackConstraints = {\n        sampleRate: { ideal: sampleRate },\n        ...defaultConstraints,\n      };\n\n      if (isIosDevice() && preferHeadphonesForIosDevices) {\n        const availableDevices =\n          await window.navigator.mediaDevices.enumerateDevices();\n        const idealDevice = availableDevices.find(\n          d =>\n            // cautious to include \"bluetooth\" in the search\n            // as might trigger bluetooth speakers\n            d.kind === \"audioinput\" &&\n            [\"airpod\", \"headphone\", \"earphone\"].find(keyword =>\n              d.label.toLowerCase().includes(keyword)\n            )\n        );\n        if (idealDevice) {\n          options.deviceId = { ideal: idealDevice.deviceId };\n        }\n      }\n\n      if (inputDeviceId) {\n        options.deviceId = Input.getDeviceIdConstraint(inputDeviceId);\n      }\n\n      const supportsSampleRateConstraint =\n        navigator.mediaDevices.getSupportedConstraints().sampleRate;\n\n      context = new window.AudioContext(\n        supportsSampleRateConstraint ? { sampleRate } : {}\n      );\n      const analyser = context.createAnalyser();\n      if (!supportsSampleRateConstraint) {\n        // Use custom libsamplerate path if provided, otherwise fallback to CDN\n        const libsamplerateUrl = libsampleratePath || LIBSAMPLERATE_JS;\n        await context.audioWorklet.addModule(libsamplerateUrl);\n      }\n      await loadRawAudioProcessor(\n        context.audioWorklet,\n        workletPaths?.[\"rawAudioProcessor\"]\n      );\n\n      const constraints = { voiceIsolation: true, ...options };\n      inputStream = await navigator.mediaDevices.getUserMedia({\n        audio: constraints,\n      });\n\n      const source = context.createMediaStreamSource(inputStream);\n      const worklet = new AudioWorkletNode(context, \"rawAudioProcessor\");\n      worklet.port.postMessage({ type: \"setFormat\", format, sampleRate });\n\n      source.connect(analyser);\n      analyser.connect(worklet);\n\n      await context.resume();\n\n      return new Input(context, analyser, worklet, inputStream, source);\n    } catch (error) {\n      inputStream?.getTracks().forEach(track => {\n        track.stop();\n      });\n      context?.close();\n      throw error;\n    }\n  }\n\n  // Use { ideal } on iOS as a defensive measure - some iOS versions may not support { exact } for deviceId constraints\n  private static getDeviceIdConstraint(\n    inputDeviceId?: string\n  ): MediaTrackConstraints[\"deviceId\"] {\n    if (!inputDeviceId) {\n      return undefined;\n    }\n    return isIosDevice() ? { ideal: inputDeviceId } : { exact: inputDeviceId };\n  }\n\n  private constructor(\n    public readonly context: AudioContext,\n    public readonly analyser: AnalyserNode,\n    public readonly worklet: AudioWorkletNode,\n    public inputStream: MediaStream,\n    private mediaStreamSource: MediaStreamAudioSourceNode\n  ) {}\n\n  public async close() {\n    this.inputStream.getTracks().forEach(track => {\n      track.stop();\n    });\n    this.mediaStreamSource.disconnect();\n    await this.context.close();\n  }\n\n  public setMuted(isMuted: boolean) {\n    this.worklet.port.postMessage({ type: \"setMuted\", isMuted });\n  }\n\n  public async setInputDevice(inputDeviceId?: string): Promise<void> {\n    try {\n      // Create new constraints with the specified device or use default\n      const options: MediaTrackConstraints = {\n        ...defaultConstraints,\n      };\n\n      if (inputDeviceId) {\n        options.deviceId = Input.getDeviceIdConstraint(inputDeviceId);\n      }\n      // If inputDeviceId is undefined, don't set deviceId constraint - browser uses default\n\n      const constraints = { voiceIsolation: true, ...options };\n\n      // Get new media stream with the specified device\n      const newInputStream = await navigator.mediaDevices.getUserMedia({\n        audio: constraints,\n      });\n\n      // Stop old tracks and disconnect old source\n      this.inputStream.getTracks().forEach(track => {\n        track.stop();\n      });\n      this.mediaStreamSource.disconnect();\n\n      // Replace the stream and create new source\n      this.inputStream = newInputStream;\n      this.mediaStreamSource =\n        this.context.createMediaStreamSource(newInputStream);\n\n      // Reconnect the audio graph\n      this.mediaStreamSource.connect(this.analyser);\n    } catch (error) {\n      console.error(\"Failed to switch input device:\", error);\n      throw error;\n    }\n  }\n}\n","// AUTO-GENERATED BY packages/client/scripts/generateWorklets.js\nimport { createWorkletModuleLoader } from \"./createWorkletModuleLoader\";\n\nexport const loadAudioConcatProcessor = createWorkletModuleLoader(\n  \"audioConcatProcessor\",\n  // language=JavaScript\n  `/*\n * ulaw decoding logic taken from the wavefile library\n * https://github.com/rochars/wavefile/blob/master/lib/codecs/mulaw.js\n * USED BY @elevenlabs/client\n */\n\nconst decodeTable = [0,132,396,924,1980,4092,8316,16764];\n\nfunction decodeSample(muLawSample) {\n  let sign;\n  let exponent;\n  let mantissa;\n  let sample;\n  muLawSample = ~muLawSample;\n  sign = (muLawSample & 0x80);\n  exponent = (muLawSample >> 4) & 0x07;\n  mantissa = muLawSample & 0x0F;\n  sample = decodeTable[exponent] + (mantissa << (exponent+3));\n  if (sign !== 0) sample = -sample;\n\n  return sample;\n}\n\nclass AudioConcatProcessor extends AudioWorkletProcessor {\n  constructor() {\n    super();\n    this.buffers = []; // Initialize an empty buffer\n    this.cursor = 0;\n    this.currentBuffer = null;\n    this.wasInterrupted = false;\n    this.finished = false;\n    \n    this.port.onmessage = ({ data }) => {\n      switch (data.type) {\n        case \"setFormat\":\n          this.format = data.format;\n          break;\n        case \"buffer\":\n          this.wasInterrupted = false;\n          this.buffers.push(\n            this.format === \"ulaw\"\n              ? new Uint8Array(data.buffer)\n              : new Int16Array(data.buffer)\n          );\n          break;\n        case \"interrupt\":\n          this.wasInterrupted = true;\n          break;\n        case \"clearInterrupted\":\n          if (this.wasInterrupted) {\n            this.wasInterrupted = false;\n            this.buffers = [];\n            this.currentBuffer = null;\n          }\n      }\n    };\n  }\n  process(_, outputs) {\n    let finished = false;\n    const output = outputs[0][0];\n    for (let i = 0; i < output.length; i++) {\n      if (!this.currentBuffer) {\n        if (this.buffers.length === 0) {\n          finished = true;\n          break;\n        }\n        this.currentBuffer = this.buffers.shift();\n        this.cursor = 0;\n      }\n\n      let value = this.currentBuffer[this.cursor];\n      if (this.format === \"ulaw\") {\n        value = decodeSample(value);\n      }\n      output[i] = value / 32768;\n      this.cursor++;\n\n      if (this.cursor >= this.currentBuffer.length) {\n        this.currentBuffer = null;\n      }\n    }\n\n    if (this.finished !== finished) {\n      this.finished = finished;\n      this.port.postMessage({ type: \"process\", finished });\n    }\n\n    return true; // Continue processing\n  }\n}\n\nregisterProcessor(\"audioConcatProcessor\", AudioConcatProcessor);\n`\n);\n","import { loadAudioConcatProcessor } from \"./audioConcatProcessor.generated\";\nimport type { FormatConfig } from \"./connection\";\nimport type { AudioWorkletConfig } from \"../BaseConversation\";\n\nexport type OutputConfig = {\n  outputDeviceId?: string;\n};\n\nexport class Output {\n  public static async create({\n    sampleRate,\n    format,\n    outputDeviceId,\n    workletPaths,\n  }: FormatConfig & OutputConfig & AudioWorkletConfig): Promise<Output> {\n    let context: AudioContext | null = null;\n    let audioElement: HTMLAudioElement | null = null;\n    try {\n      context = new AudioContext({ sampleRate });\n      const analyser = context.createAnalyser();\n      const gain = context.createGain();\n\n      // Always create an audio element for device switching capability\n      audioElement = new Audio();\n      audioElement.src = \"\";\n      audioElement.load();\n      audioElement.autoplay = true;\n      audioElement.style.display = \"none\";\n\n      document.body.appendChild(audioElement);\n\n      // Create media stream destination to route audio to the element\n      const destination = context.createMediaStreamDestination();\n      audioElement.srcObject = destination.stream;\n\n      gain.connect(analyser);\n      analyser.connect(destination);\n\n      await loadAudioConcatProcessor(\n        context.audioWorklet,\n        workletPaths?.[\"audioConcatProcessor\"]\n      );\n      const worklet = new AudioWorkletNode(context, \"audioConcatProcessor\");\n      worklet.port.postMessage({ type: \"setFormat\", format });\n      worklet.connect(gain);\n\n      await context.resume();\n\n      // Set initial output device if provided\n      if (outputDeviceId && audioElement.setSinkId) {\n        await audioElement.setSinkId(outputDeviceId);\n      }\n\n      const newOutput = new Output(\n        context,\n        analyser,\n        gain,\n        worklet,\n        audioElement\n      );\n\n      return newOutput;\n    } catch (error) {\n      // Clean up audio element from DOM\n      if (audioElement?.parentNode) {\n        audioElement.parentNode.removeChild(audioElement);\n      }\n      audioElement?.pause();\n      if (context && context.state !== \"closed\") {\n        await context.close();\n      }\n\n      throw error;\n    }\n  }\n\n  private constructor(\n    public readonly context: AudioContext,\n    public readonly analyser: AnalyserNode,\n    public readonly gain: GainNode,\n    public readonly worklet: AudioWorkletNode,\n    public readonly audioElement: HTMLAudioElement\n  ) {}\n\n  public async setOutputDevice(deviceId?: string): Promise<void> {\n    if (!(\"setSinkId\" in HTMLAudioElement.prototype)) {\n      throw new Error(\"setSinkId is not supported in this browser\");\n    }\n\n    // If deviceId is undefined, use empty string which resets to default device\n    await this.audioElement.setSinkId(deviceId || \"\");\n  }\n\n  public async close() {\n    // Remove audio element from DOM\n    if (this.audioElement.parentNode) {\n      this.audioElement.parentNode.removeChild(this.audioElement);\n    }\n    this.audioElement.pause();\n    await this.context.close();\n  }\n}\n","import { arrayBufferToBase64, base64ToArrayBuffer } from \"./utils/audio\";\nimport { Input, type InputConfig } from \"./utils/input\";\nimport { Output } from \"./utils/output\";\nimport { createConnection } from \"./utils/ConnectionFactory\";\nimport type { BaseConnection, FormatConfig } from \"./utils/BaseConnection\";\nimport { WebRTCConnection } from \"./utils/WebRTCConnection\";\nimport type { AgentAudioEvent, InterruptionEvent } from \"./utils/events\";\nimport { applyDelay } from \"./utils/applyDelay\";\nimport {\n  BaseConversation,\n  type Options,\n  type PartialOptions,\n} from \"./BaseConversation\";\nimport { WebSocketConnection } from \"./utils/WebSocketConnection\";\n\nexport class VoiceConversation extends BaseConversation {\n  public static async startSession(\n    options: PartialOptions\n  ): Promise<VoiceConversation> {\n    const fullOptions = BaseConversation.getFullOptions(options);\n\n    if (fullOptions.onStatusChange) {\n      fullOptions.onStatusChange({ status: \"connecting\" });\n    }\n    if (fullOptions.onCanSendFeedbackChange) {\n      fullOptions.onCanSendFeedbackChange({ canSendFeedback: false });\n    }\n\n    let input: Input | null = null;\n    let connection: BaseConnection | null = null;\n    let output: Output | null = null;\n    let preliminaryInputStream: MediaStream | null = null;\n\n    let wakeLock: WakeLockSentinel | null = null;\n    if (options.useWakeLock ?? true) {\n      try {\n        wakeLock = await navigator.wakeLock.request(\"screen\");\n      } catch (_e) {\n        // Wake Lock is not required for the conversation to work\n      }\n    }\n\n    try {\n      // some browsers won't allow calling getSupportedConstraints or enumerateDevices\n      // before getting approval for microphone access\n      preliminaryInputStream = await navigator.mediaDevices.getUserMedia({\n        audio: true,\n      });\n\n      await applyDelay(fullOptions.connectionDelay);\n      connection = await createConnection(options);\n      [input, output] = await Promise.all([\n        Input.create({\n          ...connection.inputFormat,\n          preferHeadphonesForIosDevices: options.preferHeadphonesForIosDevices,\n          inputDeviceId: options.inputDeviceId,\n          workletPaths: options.workletPaths,\n          libsampleratePath: options.libsampleratePath,\n        }),\n        Output.create({\n          ...connection.outputFormat,\n          outputDeviceId: options.outputDeviceId,\n          workletPaths: options.workletPaths,\n        }),\n      ]);\n\n      preliminaryInputStream?.getTracks().forEach(track => {\n        track.stop();\n      });\n      preliminaryInputStream = null;\n\n      return new VoiceConversation(\n        fullOptions,\n        connection,\n        input,\n        output,\n        wakeLock\n      );\n    } catch (error) {\n      if (fullOptions.onStatusChange) {\n        fullOptions.onStatusChange({ status: \"disconnected\" });\n      }\n      preliminaryInputStream?.getTracks().forEach(track => {\n        track.stop();\n      });\n      connection?.close();\n      await input?.close();\n      await output?.close();\n      try {\n        await wakeLock?.release();\n        wakeLock = null;\n      } catch (_e) {}\n      throw error;\n    }\n  }\n\n  private inputFrequencyData?: Uint8Array<ArrayBuffer>;\n  private outputFrequencyData?: Uint8Array<ArrayBuffer>;\n\n  protected constructor(\n    options: Options,\n    connection: BaseConnection,\n    public input: Input,\n    public output: Output,\n    public wakeLock: WakeLockSentinel | null\n  ) {\n    super(options, connection);\n    this.input.worklet.port.onmessage = this.onInputWorkletMessage;\n    this.output.worklet.port.onmessage = this.onOutputWorkletMessage;\n  }\n\n  protected override async handleEndSession() {\n    await super.handleEndSession();\n    try {\n      await this.wakeLock?.release();\n      this.wakeLock = null;\n    } catch (_e) {}\n\n    await this.input.close();\n    await this.output.close();\n  }\n\n  protected override handleInterruption(event: InterruptionEvent) {\n    super.handleInterruption(event);\n    this.fadeOutAudio();\n  }\n\n  protected override handleAudio(event: AgentAudioEvent) {\n    if (this.lastInterruptTimestamp <= event.audio_event.event_id) {\n      this.options.onAudio?.(event.audio_event.audio_base_64);\n\n      // Only play audio through the output worklet for WebSocket connections\n      // WebRTC connections handle audio playback directly through LiveKit tracks\n      if (!(this.connection instanceof WebRTCConnection)) {\n        this.addAudioBase64Chunk(event.audio_event.audio_base_64);\n      }\n\n      this.currentEventId = event.audio_event.event_id;\n      this.updateCanSendFeedback();\n      this.updateMode(\"speaking\");\n    }\n  }\n\n  private onInputWorkletMessage = (event: MessageEvent): void => {\n    const rawAudioPcmData = event.data[0];\n\n    // TODO: When supported, maxVolume can be used to avoid sending silent audio\n    // const maxVolume = event.data[1];\n\n    if (this.status === \"connected\") {\n      this.connection.sendMessage({\n        user_audio_chunk: arrayBufferToBase64(rawAudioPcmData.buffer),\n      });\n    }\n  };\n\n  private onOutputWorkletMessage = ({ data }: MessageEvent): void => {\n    if (data.type === \"process\") {\n      this.updateMode(data.finished ? \"listening\" : \"speaking\");\n    }\n  };\n\n  private addAudioBase64Chunk = (chunk: string) => {\n    this.output.gain.gain.cancelScheduledValues(\n      this.output.context.currentTime\n    );\n    this.output.gain.gain.value = this.volume;\n    this.output.worklet.port.postMessage({ type: \"clearInterrupted\" });\n    this.output.worklet.port.postMessage({\n      type: \"buffer\",\n      buffer: base64ToArrayBuffer(chunk),\n    });\n  };\n\n  private fadeOutAudio = () => {\n    // mute agent\n    this.updateMode(\"listening\");\n    this.output.worklet.port.postMessage({ type: \"interrupt\" });\n    this.output.gain.gain.exponentialRampToValueAtTime(\n      0.0001,\n      this.output.context.currentTime + 2\n    );\n\n    // reset volume back\n    setTimeout(() => {\n      this.output.gain.gain.value = this.volume;\n      this.output.worklet.port.postMessage({ type: \"clearInterrupted\" });\n    }, 2000); // Adjust the duration as needed\n  };\n\n  private calculateVolume = (frequencyData: Uint8Array) => {\n    if (frequencyData.length === 0) {\n      return 0;\n    }\n\n    // TODO: Currently this averages all frequencies, but we should probably\n    // bias towards the frequencies that are more typical for human voice\n    let volume = 0;\n    for (let i = 0; i < frequencyData.length; i++) {\n      volume += frequencyData[i] / 255;\n    }\n    volume /= frequencyData.length;\n\n    return volume < 0 ? 0 : volume > 1 ? 1 : volume;\n  };\n\n  public setMicMuted(isMuted: boolean) {\n    // Use LiveKit track muting for WebRTC connections\n    if (this.connection instanceof WebRTCConnection) {\n      this.connection.setMicMuted(isMuted);\n    } else {\n      // Use input muting for WebSocket connections\n      this.input.setMuted(isMuted);\n    }\n  }\n\n  public getInputByteFrequencyData(): Uint8Array<ArrayBuffer> {\n    this.inputFrequencyData ??= new Uint8Array(\n      this.input.analyser.frequencyBinCount\n    ) as Uint8Array<ArrayBuffer>;\n    this.input.analyser.getByteFrequencyData(this.inputFrequencyData);\n    return this.inputFrequencyData;\n  }\n\n  public getOutputByteFrequencyData(): Uint8Array<ArrayBuffer> {\n    // Use WebRTC analyser if available\n    if (this.connection instanceof WebRTCConnection) {\n      const webrtcData = this.connection.getOutputByteFrequencyData();\n      if (webrtcData) {\n        return webrtcData as Uint8Array<ArrayBuffer>;\n      }\n      // Fallback to empty array if WebRTC analyser not ready\n      return new Uint8Array(1024) as Uint8Array<ArrayBuffer>;\n    }\n\n    this.outputFrequencyData ??= new Uint8Array(\n      this.output.analyser.frequencyBinCount\n    ) as Uint8Array<ArrayBuffer>;\n    this.output.analyser.getByteFrequencyData(this.outputFrequencyData);\n    return this.outputFrequencyData;\n  }\n\n  public getInputVolume() {\n    return this.calculateVolume(this.getInputByteFrequencyData());\n  }\n\n  public getOutputVolume() {\n    return this.calculateVolume(this.getOutputByteFrequencyData());\n  }\n\n  public async changeInputDevice({\n    sampleRate,\n    format,\n    preferHeadphonesForIosDevices,\n    inputDeviceId,\n  }: FormatConfig & InputConfig): Promise<Input> {\n    try {\n      // For WebSocket connections, try to change device on existing input first\n      if (this.connection instanceof WebSocketConnection) {\n        try {\n          await this.input.setInputDevice(inputDeviceId);\n          return this.input;\n        } catch (error) {\n          console.warn(\n            \"Failed to change device on existing input, recreating:\",\n            error\n          );\n          // Fall back to recreating the input\n        }\n      }\n\n      // Handle WebRTC connections differently\n      if (this.connection instanceof WebRTCConnection) {\n        await this.connection.setAudioInputDevice(inputDeviceId || \"\");\n      }\n\n      // Fallback: recreate the input\n      await this.input.close();\n\n      const newInput = await Input.create({\n        sampleRate: sampleRate ?? this.connection.inputFormat.sampleRate,\n        format: format ?? this.connection.inputFormat.format,\n        preferHeadphonesForIosDevices,\n        inputDeviceId,\n        workletPaths: this.options.workletPaths,\n        libsampleratePath: this.options.libsampleratePath,\n      });\n\n      this.input = newInput;\n      this.input.worklet.port.onmessage = this.onInputWorkletMessage;\n\n      return this.input;\n    } catch (error) {\n      console.error(\"Error changing input device\", error);\n      throw error;\n    }\n  }\n\n  public async changeOutputDevice({\n    sampleRate,\n    format,\n    outputDeviceId,\n  }: FormatConfig): Promise<Output> {\n    try {\n      // For WebSocket connections, try to change device on existing output first\n      if (this.connection instanceof WebSocketConnection) {\n        try {\n          await this.output.setOutputDevice(outputDeviceId);\n          return this.output;\n        } catch (error) {\n          console.warn(\n            \"Failed to change device on existing output, recreating:\",\n            error\n          );\n          // Fall back to recreating the output\n        }\n      }\n\n      // Handle WebRTC connections differently\n      if (this.connection instanceof WebRTCConnection) {\n        await this.connection.setAudioOutputDevice(outputDeviceId || \"\");\n      }\n\n      // Fallback: recreate the output\n      await this.output.close();\n\n      const newOutput = await Output.create({\n        sampleRate: sampleRate ?? this.connection.outputFormat.sampleRate,\n        format: format ?? this.connection.outputFormat.format,\n        outputDeviceId,\n        workletPaths: this.options.workletPaths,\n      });\n\n      this.output = newOutput;\n\n      return this.output;\n    } catch (error) {\n      console.error(\"Error changing output device\", error);\n      throw error;\n    }\n  }\n\n  public setVolume = ({ volume }: { volume: number }) => {\n    // clamp & coerce\n    const clampedVolume = Number.isFinite(volume)\n      ? Math.min(1, Math.max(0, volume))\n      : 1;\n    this.volume = clampedVolume;\n\n    if (this.connection instanceof WebRTCConnection) {\n      // For WebRTC connections, control volume via HTML audio elements\n      this.connection.setAudioVolume(clampedVolume);\n    } else {\n      // For WebSocket connections, control volume via gain node\n      this.output.gain.gain.value = clampedVolume;\n    }\n  };\n}\n","const HTTPS_API_ORIGIN = \"https://api.elevenlabs.io\";\n\nexport interface RatingFeedback {\n  rating: number;\n  comment?: string;\n}\n\ntype Feedback = RatingFeedback;\n\nexport function postOverallFeedback(\n  conversationId: string,\n  like: boolean,\n  origin?: string\n): Promise<Response>;\nexport function postOverallFeedback(\n  conversationId: string,\n  feedback: Feedback,\n  origin?: string\n): Promise<Response>;\nexport function postOverallFeedback(\n  conversationId: string,\n  likeOrFeedback: boolean | Feedback,\n  origin: string = HTTPS_API_ORIGIN\n): Promise<Response> {\n  const body: {\n    feedback?: \"like\" | \"dislike\";\n    rating?: number;\n    comment?: string;\n  } = {};\n\n  if (typeof likeOrFeedback === \"boolean\") {\n    body.feedback = likeOrFeedback ? \"like\" : \"dislike\";\n  } else {\n    body.rating = likeOrFeedback.rating;\n    body.comment = likeOrFeedback.comment;\n  }\n\n  return fetch(`${origin}/v1/convai/conversations/${conversationId}/feedback`, {\n    method: \"POST\",\n    body: JSON.stringify(body),\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n  });\n}\n","import type {\n  InputAudioChunk,\n  SessionStartedMessage,\n  PartialTranscriptMessage,\n  CommittedTranscriptMessage,\n  CommittedTranscriptWithTimestampsMessage,\n  ScribeErrorMessage,\n  ScribeAuthErrorMessage,\n  ScribeQuotaExceededErrorMessage,\n  ScribeCommitThrottledErrorMessage,\n  ScribeTranscriberErrorMessage,\n  ScribeUnacceptedTermsErrorMessage,\n  ScribeRateLimitedErrorMessage,\n  ScribeInputErrorMessage,\n  ScribeQueueOverflowErrorMessage,\n  ScribeResourceExhaustedErrorMessage,\n  ScribeSessionTimeLimitExceededErrorMessage,\n  ScribeChunkSizeExceededErrorMessage,\n  ScribeInsufficientAudioActivityErrorMessage,\n} from \"@elevenlabs/types\";\n\n// Re-export types for public API\nexport type {\n  SessionStartedMessage,\n  PartialTranscriptMessage,\n  CommittedTranscriptMessage,\n  CommittedTranscriptWithTimestampsMessage,\n  ScribeErrorMessage,\n  ScribeAuthErrorMessage,\n  ScribeQuotaExceededErrorMessage,\n  ScribeCommitThrottledErrorMessage,\n  ScribeTranscriberErrorMessage,\n  ScribeUnacceptedTermsErrorMessage,\n  ScribeRateLimitedErrorMessage,\n  ScribeInputErrorMessage,\n  ScribeQueueOverflowErrorMessage,\n  ScribeResourceExhaustedErrorMessage,\n  ScribeSessionTimeLimitExceededErrorMessage,\n  ScribeChunkSizeExceededErrorMessage,\n  ScribeInsufficientAudioActivityErrorMessage,\n};\n\nexport type WebSocketMessage =\n  | SessionStartedMessage\n  | PartialTranscriptMessage\n  | CommittedTranscriptMessage\n  | CommittedTranscriptWithTimestampsMessage\n  | ScribeErrorMessage\n  | ScribeAuthErrorMessage\n  | ScribeQuotaExceededErrorMessage\n  | ScribeCommitThrottledErrorMessage\n  | ScribeTranscriberErrorMessage\n  | ScribeUnacceptedTermsErrorMessage\n  | ScribeRateLimitedErrorMessage\n  | ScribeInputErrorMessage\n  | ScribeQueueOverflowErrorMessage\n  | ScribeResourceExhaustedErrorMessage\n  | ScribeSessionTimeLimitExceededErrorMessage\n  | ScribeChunkSizeExceededErrorMessage\n  | ScribeInsufficientAudioActivityErrorMessage;\n\n/**\n * Simple EventEmitter implementation for browser compatibility.\n */\nclass EventEmitter {\n  private listeners: Map<string, Set<(...args: unknown[]) => void>> = new Map();\n\n  on(event: string, listener: (...args: unknown[]) => void): void {\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, new Set());\n    }\n    const eventListeners = this.listeners.get(event);\n    if (eventListeners) {\n      eventListeners.add(listener);\n    }\n  }\n\n  off(event: string, listener: (...args: unknown[]) => void): void {\n    const eventListeners = this.listeners.get(event);\n    if (eventListeners) {\n      eventListeners.delete(listener);\n    }\n  }\n\n  emit(event: string, ...args: unknown[]): void {\n    const eventListeners = this.listeners.get(event);\n    if (eventListeners) {\n      eventListeners.forEach(listener => {\n        listener(...args);\n      });\n    }\n  }\n}\n\n/**\n * Events emitted by the RealtimeConnection.\n */\nexport enum RealtimeEvents {\n  /** Emitted when the session is successfully started */\n  SESSION_STARTED = \"session_started\",\n  /** Emitted when a partial (interim) transcript is available */\n  PARTIAL_TRANSCRIPT = \"partial_transcript\",\n  /** Emitted when a final transcript is available */\n  COMMITTED_TRANSCRIPT = \"committed_transcript\",\n  /** Emitted when a final transcript with timestamps is available */\n  COMMITTED_TRANSCRIPT_WITH_TIMESTAMPS = \"committed_transcript_with_timestamps\",\n  /** Emitted when an authentication error occurs */\n  AUTH_ERROR = \"auth_error\",\n  /** Emitted when an error occurs (also emitted for all specific error types) */\n  ERROR = \"error\",\n  /** Emitted when the WebSocket connection is opened */\n  OPEN = \"open\",\n  /** Emitted when the WebSocket connection is closed */\n  CLOSE = \"close\",\n  /** Emitted when a quota exceeded error occurs */\n  QUOTA_EXCEEDED = \"quota_exceeded\",\n  /** Emitted when commit is throttled */\n  COMMIT_THROTTLED = \"commit_throttled\",\n  /** Emitted when a transcriber error occurs */\n  TRANSCRIBER_ERROR = \"transcriber_error\",\n  /** Emitted when terms have not been accepted */\n  UNACCEPTED_TERMS = \"unaccepted_terms\",\n  /** Emitted when rate limited */\n  RATE_LIMITED = \"rate_limited\",\n  /** Emitted when there's an input error */\n  INPUT_ERROR = \"input_error\",\n  /** Emitted when the queue overflows */\n  QUEUE_OVERFLOW = \"queue_overflow\",\n  /** Emitted when resources are exhausted */\n  RESOURCE_EXHAUSTED = \"resource_exhausted\",\n  /** Emitted when session time limit is exceeded */\n  SESSION_TIME_LIMIT_EXCEEDED = \"session_time_limit_exceeded\",\n  /** Emitted when chunk size is exceeded */\n  CHUNK_SIZE_EXCEEDED = \"chunk_size_exceeded\",\n  /** Emitted when there's insufficient audio activity */\n  INSUFFICIENT_AUDIO_ACTIVITY = \"insufficient_audio_activity\",\n}\n\n/**\n * Map of event types to their payload types.\n */\nexport interface RealtimeEventMap {\n  [RealtimeEvents.SESSION_STARTED]: SessionStartedMessage;\n  [RealtimeEvents.PARTIAL_TRANSCRIPT]: PartialTranscriptMessage;\n  [RealtimeEvents.COMMITTED_TRANSCRIPT]: CommittedTranscriptMessage;\n  [RealtimeEvents.COMMITTED_TRANSCRIPT_WITH_TIMESTAMPS]: CommittedTranscriptWithTimestampsMessage;\n  [RealtimeEvents.ERROR]: ScribeErrorMessage;\n  [RealtimeEvents.AUTH_ERROR]: ScribeAuthErrorMessage;\n  [RealtimeEvents.QUOTA_EXCEEDED]: ScribeQuotaExceededErrorMessage;\n  [RealtimeEvents.COMMIT_THROTTLED]: ScribeCommitThrottledErrorMessage;\n  [RealtimeEvents.TRANSCRIBER_ERROR]: ScribeTranscriberErrorMessage;\n  [RealtimeEvents.UNACCEPTED_TERMS]: ScribeUnacceptedTermsErrorMessage;\n  [RealtimeEvents.RATE_LIMITED]: ScribeRateLimitedErrorMessage;\n  [RealtimeEvents.INPUT_ERROR]: ScribeInputErrorMessage;\n  [RealtimeEvents.QUEUE_OVERFLOW]: ScribeQueueOverflowErrorMessage;\n  [RealtimeEvents.RESOURCE_EXHAUSTED]: ScribeResourceExhaustedErrorMessage;\n  [RealtimeEvents.SESSION_TIME_LIMIT_EXCEEDED]: ScribeSessionTimeLimitExceededErrorMessage;\n  [RealtimeEvents.CHUNK_SIZE_EXCEEDED]: ScribeChunkSizeExceededErrorMessage;\n  [RealtimeEvents.INSUFFICIENT_AUDIO_ACTIVITY]: ScribeInsufficientAudioActivityErrorMessage;\n  [RealtimeEvents.OPEN]: undefined;\n  [RealtimeEvents.CLOSE]: CloseEvent;\n}\n\n/**\n * Manages a real-time transcription WebSocket connection.\n *\n * @example\n * ```typescript\n * const connection = await Scribe.connect({\n *     token: \"...\",\n *     modelId: \"scribe_v2_realtime\",\n *     audioFormat: AudioFormat.PCM_16000,\n *     sampleRate: 16000,\n * });\n *\n * connection.on(RealtimeEvents.SESSION_STARTED, (data) => {\n *     console.log(\"Session started\");\n * });\n *\n * connection.on(RealtimeEvents.PARTIAL_TRANSCRIPT, (data) => {\n *     console.log(\"Partial:\", data.transcript);\n * });\n *\n * connection.on(RealtimeEvents.COMMITTED_TRANSCRIPT, (data) => {\n *     console.log(\"Final:\", data.transcript);\n *     connection.close();\n * });\n *\n * // Send audio data\n * connection.send({ audioBase64: base64String });\n *\n * // Commit and close\n * connection.commit();\n * ```\n */\nexport class RealtimeConnection {\n  private websocket: WebSocket | null = null;\n  private eventEmitter: EventEmitter = new EventEmitter();\n  private currentSampleRate: number = 16000;\n  public _audioCleanup?: () => void;\n\n  constructor(sampleRate: number) {\n    this.currentSampleRate = sampleRate;\n  }\n\n  /**\n   * @internal\n   * Used internally by ScribeRealtime to attach the WebSocket after connection is created.\n   */\n  public setWebSocket(websocket: WebSocket): void {\n    this.websocket = websocket;\n\n    // If WebSocket is already open, emit OPEN event immediately\n    if (this.websocket.readyState === WebSocket.OPEN) {\n      this.eventEmitter.emit(RealtimeEvents.OPEN);\n    } else {\n      // Otherwise, wait for the open event\n      this.websocket.addEventListener(\"open\", () => {\n        this.eventEmitter.emit(RealtimeEvents.OPEN);\n      });\n    }\n\n    this.websocket.addEventListener(\"message\", (event: MessageEvent) => {\n      try {\n        const data = JSON.parse(event.data) as WebSocketMessage;\n\n        switch (data.message_type) {\n          case \"session_started\":\n            this.eventEmitter.emit(RealtimeEvents.SESSION_STARTED, data);\n            break;\n          case \"partial_transcript\":\n            this.eventEmitter.emit(RealtimeEvents.PARTIAL_TRANSCRIPT, data);\n            break;\n          case \"committed_transcript\":\n            this.eventEmitter.emit(RealtimeEvents.COMMITTED_TRANSCRIPT, data);\n            break;\n          case \"committed_transcript_with_timestamps\":\n            this.eventEmitter.emit(\n              RealtimeEvents.COMMITTED_TRANSCRIPT_WITH_TIMESTAMPS,\n              data\n            );\n            break;\n          // Error cases - emit both specific event and generic ERROR\n          case \"auth_error\":\n            this.eventEmitter.emit(RealtimeEvents.AUTH_ERROR, data);\n            this.eventEmitter.emit(RealtimeEvents.ERROR, data);\n            break;\n          case \"quota_exceeded\":\n            this.eventEmitter.emit(RealtimeEvents.QUOTA_EXCEEDED, data);\n            this.eventEmitter.emit(RealtimeEvents.ERROR, data);\n            break;\n          case \"commit_throttled\":\n            this.eventEmitter.emit(RealtimeEvents.COMMIT_THROTTLED, data);\n            this.eventEmitter.emit(RealtimeEvents.ERROR, data);\n            break;\n          case \"transcriber_error\":\n            this.eventEmitter.emit(RealtimeEvents.TRANSCRIBER_ERROR, data);\n            this.eventEmitter.emit(RealtimeEvents.ERROR, data);\n            break;\n          case \"unaccepted_terms\":\n            this.eventEmitter.emit(RealtimeEvents.UNACCEPTED_TERMS, data);\n            this.eventEmitter.emit(RealtimeEvents.ERROR, data);\n            break;\n          case \"rate_limited\":\n            this.eventEmitter.emit(RealtimeEvents.RATE_LIMITED, data);\n            this.eventEmitter.emit(RealtimeEvents.ERROR, data);\n            break;\n          case \"input_error\":\n            this.eventEmitter.emit(RealtimeEvents.INPUT_ERROR, data);\n            this.eventEmitter.emit(RealtimeEvents.ERROR, data);\n            break;\n          case \"queue_overflow\":\n            this.eventEmitter.emit(RealtimeEvents.QUEUE_OVERFLOW, data);\n            this.eventEmitter.emit(RealtimeEvents.ERROR, data);\n            break;\n          case \"resource_exhausted\":\n            this.eventEmitter.emit(RealtimeEvents.RESOURCE_EXHAUSTED, data);\n            this.eventEmitter.emit(RealtimeEvents.ERROR, data);\n            break;\n          case \"session_time_limit_exceeded\":\n            this.eventEmitter.emit(\n              RealtimeEvents.SESSION_TIME_LIMIT_EXCEEDED,\n              data\n            );\n            this.eventEmitter.emit(RealtimeEvents.ERROR, data);\n            break;\n          case \"chunk_size_exceeded\":\n            this.eventEmitter.emit(RealtimeEvents.CHUNK_SIZE_EXCEEDED, data);\n            this.eventEmitter.emit(RealtimeEvents.ERROR, data);\n            break;\n          case \"insufficient_audio_activity\":\n            this.eventEmitter.emit(\n              RealtimeEvents.INSUFFICIENT_AUDIO_ACTIVITY,\n              data\n            );\n            this.eventEmitter.emit(RealtimeEvents.ERROR, data);\n            break;\n          case \"error\":\n            this.eventEmitter.emit(RealtimeEvents.ERROR, data);\n            break;\n          default:\n            console.warn(\"Unknown message type:\", data);\n        }\n      } catch (error) {\n        console.error(\"Failed to parse WebSocket message:\", error, event.data);\n        this.eventEmitter.emit(\n          RealtimeEvents.ERROR,\n          new Error(`Failed to parse message: ${error}`)\n        );\n      }\n    });\n\n    this.websocket.addEventListener(\"error\", (error: Event) => {\n      console.error(\"WebSocket error:\", error);\n      this.eventEmitter.emit(RealtimeEvents.ERROR, error);\n    });\n\n    this.websocket.addEventListener(\"close\", (event: CloseEvent) => {\n      console.log(\n        `WebSocket closed: code=${event.code}, reason=\"${event.reason}\", wasClean=${event.wasClean}`\n      );\n\n      // Emit error if close was not clean or had an error code\n      if (!event.wasClean || (event.code !== 1000 && event.code !== 1005)) {\n        const errorMessage = `WebSocket closed unexpectedly: ${event.code} - ${event.reason || \"No reason provided\"}`;\n        console.error(errorMessage);\n        this.eventEmitter.emit(RealtimeEvents.ERROR, new Error(errorMessage));\n      }\n\n      this.eventEmitter.emit(RealtimeEvents.CLOSE, event);\n    });\n  }\n\n  /**\n   * Attaches an event listener for the specified event.\n   *\n   * @param event - The event to listen for (use RealtimeEvents enum)\n   * @param listener - The callback function to execute when the event fires\n   *\n   * @example\n   * ```typescript\n   * connection.on(RealtimeEvents.SESSION_STARTED, (data) => {\n   *     console.log(\"Session started\", data.session_id);\n   * });\n   *\n   * connection.on(RealtimeEvents.PARTIAL_TRANSCRIPT, (data) => {\n   *     console.log(\"Partial:\", data.text);\n   * });\n   *\n   * connection.on(RealtimeEvents.COMMITTED_TRANSCRIPT, (data) => {\n   *     console.log(\"Final:\", data.text);\n   * });\n   * ```\n   */\n  public on<E extends RealtimeEvents>(\n    event: E,\n    listener: RealtimeEventMap[E] extends undefined\n      ? () => void\n      : (data: RealtimeEventMap[E]) => void\n  ): void {\n    this.eventEmitter.on(event, listener as (...args: unknown[]) => void);\n  }\n\n  /**\n   * Removes an event listener for the specified event.\n   *\n   * @param event - The event to stop listening for\n   * @param listener - The callback function to remove\n   *\n   * @example\n   * ```typescript\n   * const handler = (data: PartialTranscriptMessage) => console.log(data.text);\n   * connection.on(RealtimeEvents.PARTIAL_TRANSCRIPT, handler);\n   *\n   * // Later, remove the listener\n   * connection.off(RealtimeEvents.PARTIAL_TRANSCRIPT, handler);\n   * ```\n   */\n  public off<E extends RealtimeEvents>(\n    event: E,\n    listener: RealtimeEventMap[E] extends undefined\n      ? () => void\n      : (data: RealtimeEventMap[E]) => void\n  ): void {\n    this.eventEmitter.off(event, listener as (...args: unknown[]) => void);\n  }\n\n  /**\n   * Sends audio data to the transcription service.\n   *\n   * @param data - Audio data configuration\n   * @param data.audioBase64 - Base64-encoded audio data\n   * @param data.commit - Whether to commit the transcription after this chunk. You likely want to use connection.commit() instead (default: false)\n   * @param data.sampleRate - Sample rate of the audio (default: configured sample rate)\n   * @param data.previousText - Send context to the model via base64 encoded audio or text from a previous transcription. Can only be sent alongside the first audio chunk. If sent in a subsequent chunk, an error will be returned.\n   *\n   * @throws {Error} If the WebSocket connection is not open\n   *\n   * @example\n   * ```typescript\n   * // Send audio chunk without committing\n   * connection.send({\n   *     audioBase64: base64EncodedAudio,\n   * });\n   *\n   * // Send audio chunk with custom sample rate and previous text\n   * connection.send({\n   *     audioBase64: base64EncodedAudio,\n   *     sampleRate: 16000,\n   *     previousText: \"Previous transcription text\",\n   * });\n   * ```\n   */\n  public send(data: {\n    audioBase64: string;\n    commit?: boolean;\n    sampleRate?: number;\n    previousText?: string;\n  }): void {\n    if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN) {\n      throw new Error(\"WebSocket is not connected\");\n    }\n\n    const message: InputAudioChunk = {\n      message_type: \"input_audio_chunk\",\n      audio_base_64: data.audioBase64,\n      commit: data.commit ?? false,\n      sample_rate: data.sampleRate ?? this.currentSampleRate,\n      previous_text: data.previousText,\n    };\n\n    this.websocket.send(JSON.stringify(message));\n  }\n\n  /**\n   * Commits the transcription, signaling that a segment of audio has been sent. This clears the buffer and triggers a COMMITTED_TRANSCRIPT event. Context from previous segments is kept.\n   * Committing a segment triggers a COMMITTED_TRANSCRIPT event.\n   *\n   * @throws {Error} If the WebSocket connection is not open\n   *\n   * @remarks\n   * Only needed when using CommitStrategy.MANUAL.\n   * When using CommitStrategy.VAD, commits are handled automatically by the server.\n   *\n   * @example\n   * ```typescript\n   * // Send all audio chunks\n   * for (const chunk of audioChunks) {\n   *     connection.send({ audioBase64: chunk });\n   * }\n   *\n   * // Finalize the transcription\n   * connection.commit();\n   * ```\n   */\n  public commit(): void {\n    if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN) {\n      throw new Error(\"WebSocket is not connected\");\n    }\n\n    const message: InputAudioChunk = {\n      message_type: \"input_audio_chunk\",\n      audio_base_64: \"\",\n      commit: true,\n      sample_rate: this.currentSampleRate,\n    };\n\n    this.websocket.send(JSON.stringify(message));\n  }\n\n  /**\n   * Closes the WebSocket connection and cleans up resources.\n   * This will terminate any ongoing transcription and stop microphone streaming if active.\n   *\n   * @remarks\n   * After calling close(), this connection cannot be reused.\n   * Create a new connection if you need to start transcribing again.\n   *\n   * @example\n   * ```typescript\n   * connection.on(RealtimeEvents.COMMITTED_TRANSCRIPT, (data) => {\n   *     console.log(\"Segment committed:\", data.transcript);\n   *     connection.close();\n   * });\n   * ```\n   */\n  public close(): void {\n    // Cleanup audio resources (microphone stream, audio context)\n    if (this._audioCleanup) {\n      this._audioCleanup();\n    }\n\n    // Close WebSocket connection\n    if (this.websocket) {\n      this.websocket.close();\n    }\n  }\n}\n","// AUTO-GENERATED BY packages/client/scripts/generateWorklets.js\nimport { createWorkletModuleLoader } from \"./createWorkletModuleLoader\";\n\nexport const loadScribeAudioProcessor = createWorkletModuleLoader(\n  \"scribeAudioProcessor\",\n  // language=JavaScript\n  `/*\n * Scribe Audio Processor for converting microphone audio to PCM16 format\n * USED BY @elevenlabs/client\n */\n\nclass ScribeAudioProcessor extends AudioWorkletProcessor {\n  constructor() {\n    super();\n    this.buffer = [];\n    this.bufferSize = 4096; // Buffer size for optimal chunk transmission\n  }\n\n  process(inputs) {\n    const input = inputs[0];\n    if (input.length > 0) {\n      const channelData = input[0]; // Get first channel (mono)\n\n      // Add incoming audio to buffer\n      this.buffer.push(...channelData);\n\n      // When buffer reaches threshold, convert and send\n      if (this.buffer.length >= this.bufferSize) {\n        const float32Array = new Float32Array(this.buffer);\n        const int16Array = new Int16Array(float32Array.length);\n\n        // Convert Float32 [-1, 1] to Int16 [-32768, 32767]\n        for (let i = 0; i < float32Array.length; i++) {\n          // Clamp the value to prevent overflow\n          const sample = Math.max(-1, Math.min(1, float32Array[i]));\n          // Scale to PCM16 range\n          int16Array[i] = sample < 0 ? sample * 32768 : sample * 32767;\n        }\n\n        // Send to main thread as transferable ArrayBuffer\n        this.port.postMessage(\n          {\n            audioData: int16Array.buffer\n          },\n          [int16Array.buffer]\n        );\n\n        // Clear buffer\n        this.buffer = [];\n      }\n    }\n\n    return true; // Continue processing\n  }\n}\n\nregisterProcessor(\"scribeAudioProcessor\", ScribeAudioProcessor);\n\n`\n);\n","import { RealtimeConnection } from \"./connection\";\nimport { loadScribeAudioProcessor } from \"../utils/scribeAudioProcessor.generated\";\n\nexport enum AudioFormat {\n  PCM_8000 = \"pcm_8000\",\n  PCM_16000 = \"pcm_16000\",\n  PCM_22050 = \"pcm_22050\",\n  PCM_24000 = \"pcm_24000\",\n  PCM_44100 = \"pcm_44100\",\n  PCM_48000 = \"pcm_48000\",\n  ULAW_8000 = \"ulaw_8000\",\n}\n\nexport enum CommitStrategy {\n  MANUAL = \"manual\",\n  VAD = \"vad\",\n}\n\ninterface BaseOptions {\n  /**\n   * Token to use for the WebSocket connection. Obtained from the ElevenLabs API.\n   */\n  token: string;\n  /**\n   * Strategy for committing transcriptions.\n   * @default CommitStrategy.MANUAL\n   */\n  commitStrategy?: CommitStrategy;\n  /**\n   * Silence threshold in seconds for VAD (Voice Activity Detection).\n   * Must be a positive number between 0.3 and 3.0\n   */\n  vadSilenceThresholdSecs?: number;\n  /**\n   * Threshold for voice activity detection.\n   * Must be between 0.1 and 0.9.\n   */\n  vadThreshold?: number;\n  /**\n   * Minimum speech duration in milliseconds.\n   * Must be a positive integer between 50 and 2000.\n   */\n  minSpeechDurationMs?: number;\n  /**\n   * Minimum silence duration in milliseconds.\n   * Must be a positive integer between 50 and 2000.\n   */\n  minSilenceDurationMs?: number;\n  /**\n   * Model ID to use for transcription.\n   * Must be a valid model ID.\n   */\n  modelId: string;\n  /**\n   * An ISO-639-1 or ISO-639-3 language_code corresponding to the language of the audio file.\n   * Can sometimes improve transcription performance if known beforehand.\n   */\n  languageCode?: string;\n  /**\n   * Base URI to use for the WebSocket connection.\n   * If not provided, the default URI will be used.\n   */\n  baseUri?: string;\n  /**\n   * Whether to receive a committed_transcript_with_timestamps event which includes word-level timestamps.\n   * @default false\n   */\n  includeTimestamps?: boolean;\n}\n\nexport interface AudioOptions extends BaseOptions {\n  audioFormat: AudioFormat;\n  sampleRate: number;\n  microphone?: never;\n}\n\n/**\n * Options for automatic microphone streaming in the browser.\n */\nexport interface MicrophoneOptions extends BaseOptions {\n  microphone?: {\n    deviceId?: string;\n    echoCancellation?: boolean;\n    noiseSuppression?: boolean;\n    autoGainControl?: boolean;\n    channelCount?: number;\n  };\n  audioFormat?: never;\n  sampleRate?: never;\n}\n\n/**\n * Real-time speech-to-text transcription client for browser environments.\n * Supports microphone streaming and manual audio chunk transmission.\n */\n\n// biome-ignore lint/complexity/noStaticOnlyClass: This class is static only because it is a singleton\nexport class ScribeRealtime {\n  private static readonly DEFAULT_BASE_URI = \"wss://api.elevenlabs.io\";\n\n  private static getWebSocketUri(\n    baseUri: string = ScribeRealtime.DEFAULT_BASE_URI\n  ): string {\n    return `${baseUri}/v1/speech-to-text/realtime`;\n  }\n\n  private static buildWebSocketUri(\n    options: AudioOptions | MicrophoneOptions\n  ): string {\n    const baseUri = ScribeRealtime.getWebSocketUri(options.baseUri);\n    const params = new URLSearchParams();\n\n    // Model ID is required, so no check required\n    params.append(\"model_id\", options.modelId);\n\n    params.append(\"token\", options.token);\n\n    // Add optional parameters if provided, with validation\n    if (options.commitStrategy !== undefined) {\n      params.append(\"commit_strategy\", options.commitStrategy);\n    }\n    if (options.vadSilenceThresholdSecs !== undefined) {\n      if (\n        options.vadSilenceThresholdSecs <= 0.3 ||\n        options.vadSilenceThresholdSecs > 3.0\n      ) {\n        throw new Error(\"vadSilenceThresholdSecs must be between 0.3 and 3.0\");\n      }\n      params.append(\n        \"vad_silence_threshold_secs\",\n        options.vadSilenceThresholdSecs.toString()\n      );\n    }\n    if (options.vadThreshold !== undefined) {\n      if (options.vadThreshold < 0.1 || options.vadThreshold > 0.9) {\n        throw new Error(\"vadThreshold must be between 0.1 and 0.9\");\n      }\n      params.append(\"vad_threshold\", options.vadThreshold.toString());\n    }\n    if (options.minSpeechDurationMs !== undefined) {\n      if (\n        options.minSpeechDurationMs <= 50 ||\n        options.minSpeechDurationMs > 2000\n      ) {\n        throw new Error(\"minSpeechDurationMs must be between 50 and 2000\");\n      }\n      params.append(\n        \"min_speech_duration_ms\",\n        options.minSpeechDurationMs.toString()\n      );\n    }\n    if (options.minSilenceDurationMs !== undefined) {\n      if (\n        options.minSilenceDurationMs <= 50 ||\n        options.minSilenceDurationMs > 2000\n      ) {\n        throw new Error(\"minSilenceDurationMs must be between 50 and 2000\");\n      }\n      params.append(\n        \"min_silence_duration_ms\",\n        options.minSilenceDurationMs.toString()\n      );\n    }\n    if (options.languageCode !== undefined) {\n      params.append(\"language_code\", options.languageCode);\n    }\n    if (options.includeTimestamps !== undefined) {\n      params.append(\n        \"include_timestamps\",\n        options.includeTimestamps ? \"true\" : \"false\"\n      );\n    }\n\n    const queryString = params.toString();\n    return queryString ? `${baseUri}?${queryString}` : baseUri;\n  }\n\n  /**\n   * Establishes a WebSocket connection for real-time speech-to-text transcription.\n   *\n   * @param options - Configuration options for the connection\n   * @returns A RealtimeConnection instance\n   *\n   * @example\n   * ```typescript\n   * // Manual audio streaming\n   * const connection = Scribe.connect({\n   *     token: \"...\",\n   *     modelId: \"scribe_v2_realtime\",\n   *     audioFormat: AudioFormat.PCM_16000,\n   *     sampleRate: 16000,\n   * });\n   *\n   * // Automatic microphone streaming\n   * const connection = Scribe.connect({\n   *     token: \"...\",\n   *     modelId: \"scribe_v2_realtime\",\n   *     microphone: {\n   *         echoCancellation: true,\n   *         noiseSuppression: true\n   *     }\n   * });\n   * ```\n   */\n  public static connect(\n    options: AudioOptions | MicrophoneOptions\n  ): RealtimeConnection {\n    if (!options.modelId) {\n      throw new Error(\"modelId is required\");\n    }\n\n    // Create connection object first so users can attach event listeners before messages arrive\n    const sampleRate =\n      \"microphone\" in options && options.microphone\n        ? 16000\n        : (options as AudioOptions).sampleRate;\n    const connection = new RealtimeConnection(sampleRate);\n\n    // Build WebSocket URI with query parameters\n    const uri = ScribeRealtime.buildWebSocketUri(options);\n\n    const websocket = new WebSocket(uri);\n\n    // If microphone mode, set up streaming handler\n    if (\"microphone\" in options && options.microphone) {\n      websocket.addEventListener(\"open\", () => {\n        ScribeRealtime.streamFromMicrophone(\n          options as MicrophoneOptions,\n          connection\n        );\n      });\n    }\n\n    connection.setWebSocket(websocket);\n\n    return connection;\n  }\n\n  private static async streamFromMicrophone(\n    options: MicrophoneOptions,\n    connection: RealtimeConnection\n  ): Promise<void> {\n    try {\n      // Get microphone access\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: {\n          deviceId: options.microphone?.deviceId,\n          echoCancellation: options.microphone?.echoCancellation ?? true,\n          noiseSuppression: options.microphone?.noiseSuppression ?? true,\n          autoGainControl: options.microphone?.autoGainControl ?? true,\n          channelCount: options.microphone?.channelCount ?? 1,\n          sampleRate: { ideal: 16000 },\n        },\n      });\n\n      // Create audio context at 16kHz (Scribe's default)\n      const audioContext = new AudioContext({ sampleRate: 16000 });\n\n      // Load scribe worklet\n      await loadScribeAudioProcessor(audioContext.audioWorklet);\n\n      // Set up audio pipeline\n      const source = audioContext.createMediaStreamSource(stream);\n      const workletNode = new AudioWorkletNode(\n        audioContext,\n        \"scribeAudioProcessor\"\n      );\n\n      // Handle audio data from worklet\n      workletNode.port.onmessage = event => {\n        const { audioData } = event.data;\n        // Convert ArrayBuffer to base64\n        const bytes = new Uint8Array(audioData);\n        let binary = \"\";\n        for (let i = 0; i < bytes.length; i++) {\n          binary += String.fromCharCode(bytes[i]);\n        }\n        const base64Audio = btoa(binary);\n\n        connection.send({ audioBase64: base64Audio });\n      };\n\n      // Connect audio pipeline\n      source.connect(workletNode);\n\n      // Resume audio context if needed\n      if (audioContext.state === \"suspended\") {\n        await audioContext.resume();\n      }\n\n      // Store cleanup function\n      connection._audioCleanup = () => {\n        stream.getTracks().forEach(track => {\n          track.stop();\n        });\n        source.disconnect();\n        workletNode.disconnect();\n        audioContext.close();\n      };\n    } catch (error) {\n      console.error(\"Failed to start microphone streaming:\", error);\n      throw error;\n    }\n  }\n}\n","import { BaseConversation, type PartialOptions } from \"./BaseConversation\";\nimport { TextConversation } from \"./TextConversation\";\nimport { VoiceConversation } from \"./VoiceConversation\";\n\nexport type {\n  Mode,\n  Role,\n  Options,\n  PartialOptions,\n  ClientToolsConfig,\n  Callbacks,\n  Status,\n  AudioWorkletConfig,\n} from \"./BaseConversation\";\nexport type { InputConfig } from \"./utils/input\";\nexport type { OutputConfig } from \"./utils/output\";\nexport { Input } from \"./utils/input\";\nexport { Output } from \"./utils/output\";\nexport type { IncomingSocketEvent, VadScoreEvent } from \"./utils/events\";\nexport type {\n  SessionConfig,\n  BaseSessionConfig,\n  DisconnectionDetails,\n  Language,\n  ConnectionType,\n  FormatConfig,\n} from \"./utils/BaseConnection\";\nexport { createConnection } from \"./utils/ConnectionFactory\";\nexport { WebSocketConnection } from \"./utils/WebSocketConnection\";\nexport { WebRTCConnection } from \"./utils/WebRTCConnection\";\nexport { postOverallFeedback } from \"./utils/postOverallFeedback\";\nexport { VoiceConversation } from \"./VoiceConversation\";\nexport { TextConversation } from \"./TextConversation\";\n\n// Scribe exports\nexport {\n  Scribe,\n  AudioFormat,\n  CommitStrategy,\n  RealtimeEvents,\n  RealtimeConnection,\n} from \"./scribe\";\nexport type {\n  AudioOptions,\n  MicrophoneOptions,\n  WebSocketMessage,\n  PartialTranscriptMessage,\n  CommittedTranscriptMessage,\n  CommittedTranscriptWithTimestampsMessage,\n  ScribeErrorMessage,\n  ScribeAuthErrorMessage,\n  ScribeQuotaExceededErrorMessage,\n  ScribeCommitThrottledErrorMessage,\n  ScribeTranscriberErrorMessage,\n  ScribeUnacceptedTermsErrorMessage,\n  ScribeRateLimitedErrorMessage,\n  ScribeInputErrorMessage,\n  ScribeQueueOverflowErrorMessage,\n  ScribeResourceExhaustedErrorMessage,\n  ScribeSessionTimeLimitExceededErrorMessage,\n  ScribeChunkSizeExceededErrorMessage,\n  ScribeInsufficientAudioActivityErrorMessage,\n} from \"./scribe\";\n\nexport class Conversation extends BaseConversation {\n  public static startSession(options: PartialOptions): Promise<Conversation> {\n    return options.textOnly\n      ? TextConversation.startSession(options)\n      : VoiceConversation.startSession(options);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}