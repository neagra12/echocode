{"ast":null,"code":"import { useRef as n, useState as e, useEffect as r, useCallback as o } from \"react\";\nimport { Scribe as t, RealtimeEvents as l, Conversation as i } from \"@elevenlabs/client\";\nexport { AudioFormat, CommitStrategy, RealtimeEvents, postOverallFeedback } from \"@elevenlabs/client\";\nfunction u() {\n  return u = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var r = arguments[e];\n      for (var o in r) ({}).hasOwnProperty.call(r, o) && (n[o] = r[o]);\n    }\n    return n;\n  }, u.apply(null, arguments);\n}\nfunction a(i = {}) {\n  const {\n      onSessionStarted: a,\n      onPartialTranscript: s,\n      onCommittedTranscript: c,\n      onCommittedTranscriptWithTimestamps: d,\n      onError: v,\n      onAuthError: m,\n      onQuotaExceededError: g,\n      onCommitThrottledError: p,\n      onTranscriberError: T,\n      onUnacceptedTermsError: C,\n      onRateLimitedError: h,\n      onInputError: E,\n      onQueueOverflowError: S,\n      onResourceExhaustedError: M,\n      onSessionTimeLimitExceededError: I,\n      onChunkSizeExceededError: D,\n      onInsufficientAudioActivityError: R,\n      onConnect: b,\n      onDisconnect: w,\n      token: y,\n      modelId: A,\n      baseUri: f,\n      commitStrategy: O,\n      vadSilenceThresholdSecs: U,\n      vadThreshold: k,\n      minSpeechDurationMs: F,\n      minSilenceDurationMs: _,\n      languageCode: P,\n      microphone: x,\n      audioFormat: N,\n      sampleRate: V,\n      autoConnect: L = !1,\n      includeTimestamps: q\n    } = i,\n    B = n(null),\n    [H, $] = e(\"disconnected\"),\n    [Q, W] = e(\"\"),\n    [X, j] = e([]),\n    [z, K] = e(null);\n  r(() => () => {\n    var n;\n    null == (n = B.current) || n.close();\n  }, []);\n  const Y = o(async (n = {}) => {\n      if (B.current) console.warn(\"Already connected\");else try {\n        var e, r;\n        $(\"connecting\"), K(null);\n        const o = n.token || y,\n          i = n.modelId || A;\n        if (!o) throw new Error(\"Token is required\");\n        if (!i) throw new Error(\"Model ID is required\");\n        const u = n.microphone || x,\n          L = n.audioFormat || N,\n          H = n.sampleRate || V;\n        let Q;\n        const X = null != (e = null != (r = n.includeTimestamps) ? r : q) ? e : !(!n.onCommittedTranscriptWithTimestamps && !d);\n        if (u) Q = t.connect({\n          token: o,\n          modelId: i,\n          baseUri: n.baseUri || f,\n          commitStrategy: n.commitStrategy || O,\n          vadSilenceThresholdSecs: n.vadSilenceThresholdSecs || U,\n          vadThreshold: n.vadThreshold || k,\n          minSpeechDurationMs: n.minSpeechDurationMs || F,\n          minSilenceDurationMs: n.minSilenceDurationMs || _,\n          languageCode: n.languageCode || P,\n          microphone: u,\n          includeTimestamps: X\n        });else {\n          if (!L || !H) throw new Error(\"Either microphone options or (audioFormat + sampleRate) must be provided\");\n          Q = t.connect({\n            token: o,\n            modelId: i,\n            baseUri: n.baseUri || f,\n            commitStrategy: n.commitStrategy || O,\n            vadSilenceThresholdSecs: n.vadSilenceThresholdSecs || U,\n            vadThreshold: n.vadThreshold || k,\n            minSpeechDurationMs: n.minSpeechDurationMs || F,\n            minSilenceDurationMs: n.minSilenceDurationMs || _,\n            languageCode: n.languageCode || P,\n            includeTimestamps: X,\n            audioFormat: L,\n            sampleRate: H\n          });\n        }\n        B.current = Q, Q.on(l.SESSION_STARTED, () => {\n          $(\"connected\"), null == a || a();\n        }), Q.on(l.PARTIAL_TRANSCRIPT, n => {\n          const e = n;\n          W(e.text), $(\"transcribing\"), null == s || s(e);\n        }), Q.on(l.COMMITTED_TRANSCRIPT, n => {\n          const e = n,\n            r = {\n              id: `${Date.now()}-${Math.random()}`,\n              text: e.text,\n              timestamp: Date.now(),\n              isFinal: !0\n            };\n          j(n => [...n, r]), W(\"\"), null == c || c(e);\n        }), Q.on(l.COMMITTED_TRANSCRIPT_WITH_TIMESTAMPS, n => {\n          const e = n,\n            r = {\n              id: `${Date.now()}-${Math.random()}`,\n              text: e.text,\n              timestamp: Date.now(),\n              isFinal: !0,\n              words: e.words\n            };\n          j(n => [...n, r]), W(\"\"), null == d || d(e);\n        }), Q.on(l.ERROR, n => {\n          const e = n;\n          K(e.error), $(\"error\"), null == v || v(new Error(e.error));\n        }), Q.on(l.AUTH_ERROR, n => {\n          const e = n;\n          K(e.error), $(\"error\"), null == m || m(e);\n        }), Q.on(l.QUOTA_EXCEEDED, n => {\n          const e = n;\n          K(e.error), $(\"error\"), null == g || g(e);\n        }), Q.on(l.COMMIT_THROTTLED, n => {\n          const e = n;\n          K(e.error), $(\"error\"), null == p || p(e);\n        }), Q.on(l.TRANSCRIBER_ERROR, n => {\n          const e = n;\n          K(e.error), $(\"error\"), null == T || T(e);\n        }), Q.on(l.UNACCEPTED_TERMS, n => {\n          const e = n;\n          K(e.error), $(\"error\"), null == C || C(e);\n        }), Q.on(l.RATE_LIMITED, n => {\n          const e = n;\n          K(e.error), $(\"error\"), null == h || h(e);\n        }), Q.on(l.INPUT_ERROR, n => {\n          const e = n;\n          K(e.error), $(\"error\"), null == E || E(e);\n        }), Q.on(l.QUEUE_OVERFLOW, n => {\n          const e = n;\n          K(e.error), $(\"error\"), null == S || S(e);\n        }), Q.on(l.RESOURCE_EXHAUSTED, n => {\n          const e = n;\n          K(e.error), $(\"error\"), null == M || M(e);\n        }), Q.on(l.SESSION_TIME_LIMIT_EXCEEDED, n => {\n          const e = n;\n          K(e.error), $(\"error\"), null == I || I(e);\n        }), Q.on(l.CHUNK_SIZE_EXCEEDED, n => {\n          const e = n;\n          K(e.error), $(\"error\"), null == D || D(e);\n        }), Q.on(l.INSUFFICIENT_AUDIO_ACTIVITY, n => {\n          const e = n;\n          K(e.error), $(\"error\"), null == R || R(e);\n        }), Q.on(l.OPEN, () => {\n          null == b || b();\n        }), Q.on(l.CLOSE, () => {\n          $(\"disconnected\"), B.current = null, null == w || w();\n        });\n      } catch (n) {\n        const e = n instanceof Error ? n.message : \"Failed to connect\";\n        throw K(e), $(\"error\"), n;\n      }\n    }, [y, A, f, O, U, k, F, _, P, x, N, V, q, a, s, c, d, v, m, g, p, T, C, h, E, S, M, I, D, R, b, w]),\n    Z = o(() => {\n      var n;\n      null == (n = B.current) || n.close(), B.current = null, $(\"disconnected\");\n    }, []),\n    G = o((n, e) => {\n      if (!B.current) throw new Error(\"Not connected to Scribe\");\n      B.current.send(u({\n        audioBase64: n\n      }, e));\n    }, []),\n    J = o(() => {\n      if (!B.current) throw new Error(\"Not connected to Scribe\");\n      B.current.commit();\n    }, []),\n    nn = o(() => {\n      j([]), W(\"\");\n    }, []),\n    en = o(() => B.current, []);\n  return r(() => {\n    L && Y();\n  }, [L, Y]), {\n    status: H,\n    isConnected: \"connected\" === H || \"transcribing\" === H,\n    isTranscribing: \"transcribing\" === H,\n    partialTranscript: Q,\n    committedTranscripts: X,\n    error: z,\n    connect: Y,\n    disconnect: Z,\n    sendAudio: G,\n    commit: J,\n    clearTranscripts: nn,\n    getConnection: en\n  };\n}\nconst s = [\"micMuted\", \"volume\", \"serverLocation\"];\nfunction c(n = \"us\") {\n  switch (n) {\n    case \"eu-residency\":\n    case \"in-residency\":\n    case \"us\":\n    case \"global\":\n      return n;\n    default:\n      return console.warn(`[ConversationalAI] Invalid server-location: ${n}. Defaulting to \"us\"`), \"us\";\n  }\n}\nfunction d(n) {\n  return {\n    us: \"wss://api.elevenlabs.io\",\n    \"eu-residency\": \"wss://api.eu.residency.elevenlabs.io\",\n    \"in-residency\": \"wss://api.in.residency.elevenlabs.io\",\n    global: \"wss://api.elevenlabs.io\"\n  }[n];\n}\nfunction v(n) {\n  return {\n    us: \"wss://livekit.rtc.elevenlabs.io\",\n    \"eu-residency\": \"wss://livekit.rtc.eu.residency.elevenlabs.io\",\n    \"in-residency\": \"wss://livekit.rtc.in.residency.elevenlabs.io\",\n    global: \"wss://livekit.rtc.elevenlabs.io\"\n  }[n];\n}\nfunction m(o = {}) {\n  const {\n      micMuted: t,\n      volume: l,\n      serverLocation: a\n    } = o,\n    m = function (n, e) {\n      if (null == n) return {};\n      var r = {};\n      for (var o in n) if ({}.hasOwnProperty.call(n, o)) {\n        if (-1 !== e.indexOf(o)) continue;\n        r[o] = n[o];\n      }\n      return r;\n    }(o, s),\n    g = n(null),\n    p = n(null),\n    [T, C] = e(\"disconnected\"),\n    [h, E] = e(!1),\n    [S, M] = e(\"listening\"),\n    I = n(t),\n    D = n(l);\n  return I.current = t, D.current = l, r(() => {\n    var n;\n    void 0 !== t && (null == g || null == (n = g.current) || n.setMicMuted(t));\n  }, [t]), r(() => {\n    var n;\n    void 0 !== l && (null == g || null == (n = g.current) || n.setVolume({\n      volume: l\n    }));\n  }, [l]), r(() => () => {\n    var n;\n    null == (n = g.current) || n.endSession();\n  }, []), {\n    startSession: async n => {\n      var e;\n      if (null != (e = g.current) && e.isOpen()) return g.current.getId();\n      if (p.current) return (await p.current).getId();\n      try {\n        var r, o, t, l, s, T, h, S, R, b;\n        const e = c((null == n ? void 0 : n.serverLocation) || a),\n          w = d(e),\n          y = v(e);\n        return p.current = i.startSession(u({}, null != m ? m : {}, null != n ? n : {}, {\n          origin: w,\n          livekitUrl: (null == n ? void 0 : n.livekitUrl) || (null == m ? void 0 : m.livekitUrl) || y,\n          overrides: u({}, null != (r = null == m ? void 0 : m.overrides) ? r : {}, null != (o = null == n ? void 0 : n.overrides) ? o : {}, {\n            client: u({}, null != (t = null == m || null == (l = m.overrides) ? void 0 : l.client) ? t : {}, null != (s = null == n || null == (T = n.overrides) ? void 0 : T.client) ? s : {}, {\n              source: (null == n || null == (h = n.overrides) || null == (h = h.client) ? void 0 : h.source) || (null == m || null == (S = m.overrides) || null == (S = S.client) ? void 0 : S.source) || \"react_sdk\",\n              version: (null == n || null == (R = n.overrides) || null == (R = R.client) ? void 0 : R.version) || (null == m || null == (b = m.overrides) || null == (b = b.client) ? void 0 : b.version) || \"0.12.1\"\n            })\n          }),\n          onConnect: (null == n ? void 0 : n.onConnect) || (null == m ? void 0 : m.onConnect),\n          onDisconnect: (null == n ? void 0 : n.onDisconnect) || (null == m ? void 0 : m.onDisconnect),\n          onError: (null == n ? void 0 : n.onError) || (null == m ? void 0 : m.onError),\n          onMessage: (null == n ? void 0 : n.onMessage) || (null == m ? void 0 : m.onMessage),\n          onAudio: (null == n ? void 0 : n.onAudio) || (null == m ? void 0 : m.onAudio),\n          onDebug: (null == n ? void 0 : n.onDebug) || (null == m ? void 0 : m.onDebug),\n          onUnhandledClientToolCall: (null == n ? void 0 : n.onUnhandledClientToolCall) || (null == m ? void 0 : m.onUnhandledClientToolCall),\n          onVadScore: (null == n ? void 0 : n.onVadScore) || (null == m ? void 0 : m.onVadScore),\n          onInterruption: (null == n ? void 0 : n.onInterruption) || (null == m ? void 0 : m.onInterruption),\n          onAgentToolRequest: (null == n ? void 0 : n.onAgentToolRequest) || (null == m ? void 0 : m.onAgentToolRequest),\n          onAgentToolResponse: (null == n ? void 0 : n.onAgentToolResponse) || (null == m ? void 0 : m.onAgentToolResponse),\n          onConversationMetadata: (null == n ? void 0 : n.onConversationMetadata) || (null == m ? void 0 : m.onConversationMetadata),\n          onMCPToolCall: (null == n ? void 0 : n.onMCPToolCall) || (null == m ? void 0 : m.onMCPToolCall),\n          onMCPConnectionStatus: (null == n ? void 0 : n.onMCPConnectionStatus) || (null == m ? void 0 : m.onMCPConnectionStatus),\n          onAsrInitiationMetadata: (null == n ? void 0 : n.onAsrInitiationMetadata) || (null == m ? void 0 : m.onAsrInitiationMetadata),\n          onAgentChatResponsePart: (null == n ? void 0 : n.onAgentChatResponsePart) || (null == m ? void 0 : m.onAgentChatResponsePart),\n          onModeChange: ({\n            mode: e\n          }) => {\n            var r;\n            M(e), null == (r = (null == n ? void 0 : n.onModeChange) || (null == m ? void 0 : m.onModeChange)) || r({\n              mode: e\n            });\n          },\n          onStatusChange: ({\n            status: e\n          }) => {\n            var r;\n            C(e), null == (r = (null == n ? void 0 : n.onStatusChange) || (null == m ? void 0 : m.onStatusChange)) || r({\n              status: e\n            });\n          },\n          onCanSendFeedbackChange: ({\n            canSendFeedback: e\n          }) => {\n            var r;\n            E(e), null == (r = (null == n ? void 0 : n.onCanSendFeedbackChange) || (null == m ? void 0 : m.onCanSendFeedbackChange)) || r({\n              canSendFeedback: e\n            });\n          }\n        })), g.current = await p.current, void 0 !== I.current && g.current.setMicMuted(I.current), void 0 !== D.current && g.current.setVolume({\n          volume: D.current\n        }), g.current.getId();\n      } finally {\n        p.current = null;\n      }\n    },\n    endSession: async () => {\n      const n = g.current;\n      g.current = null, await (null == n ? void 0 : n.endSession());\n    },\n    setVolume: ({\n      volume: n\n    }) => {\n      var e;\n      null == (e = g.current) || e.setVolume({\n        volume: n\n      });\n    },\n    getInputByteFrequencyData: () => {\n      var n;\n      return null == (n = g.current) ? void 0 : n.getInputByteFrequencyData();\n    },\n    getOutputByteFrequencyData: () => {\n      var n;\n      return null == (n = g.current) ? void 0 : n.getOutputByteFrequencyData();\n    },\n    getInputVolume: () => {\n      var n, e;\n      return null != (n = null == (e = g.current) ? void 0 : e.getInputVolume()) ? n : 0;\n    },\n    getOutputVolume: () => {\n      var n, e;\n      return null != (n = null == (e = g.current) ? void 0 : e.getOutputVolume()) ? n : 0;\n    },\n    sendFeedback: n => {\n      var e;\n      null == (e = g.current) || e.sendFeedback(n);\n    },\n    getId: () => {\n      var n;\n      return null == (n = g.current) ? void 0 : n.getId();\n    },\n    sendContextualUpdate: n => {\n      var e;\n      null == (e = g.current) || e.sendContextualUpdate(n);\n    },\n    sendUserMessage: n => {\n      var e;\n      null == (e = g.current) || e.sendUserMessage(n);\n    },\n    sendUserActivity: () => {\n      var n;\n      null == (n = g.current) || n.sendUserActivity();\n    },\n    sendMCPToolApprovalResult: (n, e) => {\n      var r;\n      null == (r = g.current) || r.sendMCPToolApprovalResult(n, e);\n    },\n    changeInputDevice: async n => {\n      if (g.current && \"changeInputDevice\" in g.current) return await g.current.changeInputDevice(n);\n      throw new Error(\"Device switching is only available for voice conversations\");\n    },\n    changeOutputDevice: async n => {\n      if (g.current && \"changeOutputDevice\" in g.current) return await g.current.changeOutputDevice(n);\n      throw new Error(\"Device switching is only available for voice conversations\");\n    },\n    status: T,\n    canSendFeedback: h,\n    micMuted: t,\n    isSpeaking: \"speaking\" === S\n  };\n}\nexport { v as getLivekitUrlForLocation, d as getOriginForLocation, c as parseLocation, m as useConversation, a as useScribe };","map":{"version":3,"names":["a","i","onSessionStarted","onPartialTranscript","s","onCommittedTranscript","c","onCommittedTranscriptWithTimestamps","d","onError","v","onAuthError","m","onQuotaExceededError","g","onCommitThrottledError","p","onTranscriberError","T","onUnacceptedTermsError","C","onRateLimitedError","h","onInputError","E","onQueueOverflowError","S","onResourceExhaustedError","M","onSessionTimeLimitExceededError","I","onChunkSizeExceededError","D","onInsufficientAudioActivityError","R","onConnect","b","onDisconnect","w","token","y","modelId","A","baseUri","f","commitStrategy","O","vadSilenceThresholdSecs","U","vadThreshold","k","minSpeechDurationMs","F","minSilenceDurationMs","_","languageCode","P","microphone","x","audioFormat","N","sampleRate","V","autoConnect","L","includeTimestamps","q","B","n","H","$","e","Q","W","X","j","z","K","r","current","close","Y","o","console","warn","Error","u","t","connect","on","l","SESSION_STARTED","PARTIAL_TRANSCRIPT","text","COMMITTED_TRANSCRIPT","id","Date","now","Math","random","timestamp","isFinal","COMMITTED_TRANSCRIPT_WITH_TIMESTAMPS","words","ERROR","error","AUTH_ERROR","QUOTA_EXCEEDED","COMMIT_THROTTLED","TRANSCRIBER_ERROR","UNACCEPTED_TERMS","RATE_LIMITED","INPUT_ERROR","QUEUE_OVERFLOW","RESOURCE_EXHAUSTED","SESSION_TIME_LIMIT_EXCEEDED","CHUNK_SIZE_EXCEEDED","INSUFFICIENT_AUDIO_ACTIVITY","OPEN","CLOSE","message","Z","G","send","audioBase64","J","commit","nn","en","status","isConnected","isTranscribing","partialTranscript","committedTranscripts","disconnect","sendAudio","clearTranscripts","getConnection","us","global","micMuted","volume","serverLocation","hasOwnProperty","call","indexOf","setMicMuted","setVolume","endSession","startSession","isOpen","getId","origin","livekitUrl","overrides","client","source","version","onMessage","onAudio","onDebug","onUnhandledClientToolCall","onVadScore","onInterruption","onAgentToolRequest","onAgentToolResponse","onConversationMetadata","onMCPToolCall","onMCPConnectionStatus","onAsrInitiationMetadata","onAgentChatResponsePart","onModeChange","mode","onStatusChange","onCanSendFeedbackChange","canSendFeedback","getInputByteFrequencyData","getOutputByteFrequencyData","getInputVolume","getOutputVolume","sendFeedback","sendContextualUpdate","sendUserMessage","sendUserActivity","sendMCPToolApprovalResult","changeInputDevice","changeOutputDevice","isSpeaking","getLivekitUrlForLocation","getOriginForLocation","parseLocation","useConversation","useScribe"],"sources":["C:\\Users\\neeha\\echocode\\frontend\\node_modules\\@elevenlabs\\react\\src\\scribe.ts","C:\\Users\\neeha\\echocode\\frontend\\node_modules\\@elevenlabs\\react\\src\\index.ts","C:\\Users\\neeha\\echocode\\frontend\\node_modules\\@elevenlabs\\react\\src\\version.ts"],"sourcesContent":["import { useEffect, useRef, useState, useCallback } from \"react\";\nimport { Scribe, RealtimeEvents } from \"@elevenlabs/client\";\nimport type {\n  RealtimeConnection,\n  AudioOptions,\n  MicrophoneOptions,\n  AudioFormat,\n  CommitStrategy,\n  PartialTranscriptMessage,\n  CommittedTranscriptMessage,\n  CommittedTranscriptWithTimestampsMessage,\n  ScribeErrorMessage,\n  ScribeAuthErrorMessage,\n  ScribeQuotaExceededErrorMessage,\n  ScribeCommitThrottledErrorMessage,\n  ScribeTranscriberErrorMessage,\n  ScribeUnacceptedTermsErrorMessage,\n  ScribeRateLimitedErrorMessage,\n  ScribeInputErrorMessage,\n  ScribeQueueOverflowErrorMessage,\n  ScribeResourceExhaustedErrorMessage,\n  ScribeSessionTimeLimitExceededErrorMessage,\n  ScribeChunkSizeExceededErrorMessage,\n  ScribeInsufficientAudioActivityErrorMessage,\n} from \"@elevenlabs/client\";\n\n// ============= Types =============\n\nexport type ScribeStatus =\n  | \"disconnected\"\n  | \"connecting\"\n  | \"connected\"\n  | \"transcribing\"\n  | \"error\";\n\nexport interface WordTimestamp {\n  text?: string;\n  /** Start time in seconds */\n  start?: number;\n  /** End time in seconds */\n  end?: number;\n  type?: \"word\" | \"spacing\";\n  speaker_id?: string;\n  logprob?: number;\n  characters?: string[];\n}\n\nexport interface TranscriptSegment {\n  id: string;\n  text: string;\n  timestamp: number;\n  isFinal: boolean;\n  /** Word-level timestamps (only present when includeTimestamps is enabled) */\n  words?: WordTimestamp[];\n}\n\nexport interface ScribeCallbacks {\n  onSessionStarted?: () => void;\n  onPartialTranscript?: (data: { text: string }) => void;\n  onCommittedTranscript?: (data: { text: string }) => void;\n  onCommittedTranscriptWithTimestamps?: (data: {\n    text: string;\n    words?: WordTimestamp[];\n  }) => void;\n  /** Called for any error (also called when specific error callbacks fire) */\n  onError?: (error: Error | Event) => void;\n  onAuthError?: (data: { error: string }) => void;\n  onQuotaExceededError?: (data: { error: string }) => void;\n  onCommitThrottledError?: (data: { error: string }) => void;\n  onTranscriberError?: (data: { error: string }) => void;\n  onUnacceptedTermsError?: (data: { error: string }) => void;\n  onRateLimitedError?: (data: { error: string }) => void;\n  onInputError?: (data: { error: string }) => void;\n  onQueueOverflowError?: (data: { error: string }) => void;\n  onResourceExhaustedError?: (data: { error: string }) => void;\n  onSessionTimeLimitExceededError?: (data: { error: string }) => void;\n  onChunkSizeExceededError?: (data: { error: string }) => void;\n  onInsufficientAudioActivityError?: (data: { error: string }) => void;\n\n  onConnect?: () => void;\n  onDisconnect?: () => void;\n}\n\nexport interface ScribeHookOptions extends ScribeCallbacks {\n  // Connection options\n  token?: string;\n  modelId?: string;\n  baseUri?: string;\n\n  // VAD options\n  commitStrategy?: CommitStrategy;\n  vadSilenceThresholdSecs?: number;\n  vadThreshold?: number;\n  minSpeechDurationMs?: number;\n  minSilenceDurationMs?: number;\n  languageCode?: string;\n\n  // Microphone options (for automatic microphone mode)\n  microphone?: {\n    deviceId?: string;\n    echoCancellation?: boolean;\n    noiseSuppression?: boolean;\n    autoGainControl?: boolean;\n    channelCount?: number;\n  };\n\n  // Manual audio options\n  audioFormat?: AudioFormat;\n  sampleRate?: number;\n\n  // Auto-connect on mount\n  autoConnect?: boolean;\n\n  // Include timestamps\n  includeTimestamps?: boolean;\n}\n\nexport interface UseScribeReturn {\n  // State\n  status: ScribeStatus;\n  isConnected: boolean;\n  isTranscribing: boolean;\n  partialTranscript: string;\n  committedTranscripts: TranscriptSegment[];\n  error: string | null;\n\n  // Connection methods\n  connect: (options?: Partial<ScribeHookOptions>) => Promise<void>;\n  disconnect: () => void;\n\n  // Audio methods (for manual mode)\n  sendAudio: (\n    audioBase64: string,\n    options?: { commit?: boolean; sampleRate?: number; previousText?: string }\n  ) => void;\n  commit: () => void;\n\n  // Utility methods\n  clearTranscripts: () => void;\n  getConnection: () => RealtimeConnection | null;\n}\n\n// ============= Hook Implementation =============\n\nexport function useScribe(options: ScribeHookOptions = {}): UseScribeReturn {\n  const {\n    // Callbacks\n    onSessionStarted,\n    onPartialTranscript,\n    onCommittedTranscript,\n    onCommittedTranscriptWithTimestamps,\n    onError,\n    onAuthError,\n    onQuotaExceededError,\n    onCommitThrottledError,\n    onTranscriberError,\n    onUnacceptedTermsError,\n    onRateLimitedError,\n    onInputError,\n    onQueueOverflowError,\n    onResourceExhaustedError,\n    onSessionTimeLimitExceededError,\n    onChunkSizeExceededError,\n    onInsufficientAudioActivityError,\n    onConnect,\n    onDisconnect,\n\n    // Connection options\n    token: defaultToken,\n    modelId: defaultModelId,\n    baseUri: defaultBaseUri,\n    commitStrategy: defaultCommitStrategy,\n    vadSilenceThresholdSecs: defaultVadSilenceThresholdSecs,\n    vadThreshold: defaultVadThreshold,\n    minSpeechDurationMs: defaultMinSpeechDurationMs,\n    minSilenceDurationMs: defaultMinSilenceDurationMs,\n    languageCode: defaultLanguageCode,\n\n    // Mode options\n    microphone: defaultMicrophone,\n    audioFormat: defaultAudioFormat,\n    sampleRate: defaultSampleRate,\n\n    // Auto-connect\n    autoConnect = false,\n\n    // Timestamps\n    includeTimestamps: defaultIncludeTimestamps,\n  } = options;\n\n  const connectionRef = useRef<RealtimeConnection | null>(null);\n\n  const [status, setStatus] = useState<ScribeStatus>(\"disconnected\");\n  const [partialTranscript, setPartialTranscript] = useState<string>(\"\");\n  const [committedTranscripts, setCommittedTranscripts] = useState<\n    TranscriptSegment[]\n  >([]);\n  const [error, setError] = useState<string | null>(null);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      connectionRef.current?.close();\n    };\n  }, []);\n\n  const connect = useCallback(\n    async (runtimeOptions: Partial<ScribeHookOptions> = {}) => {\n      if (connectionRef.current) {\n        console.warn(\"Already connected\");\n        return;\n      }\n\n      try {\n        setStatus(\"connecting\");\n        setError(null);\n\n        // Merge default options with runtime options\n        const token = runtimeOptions.token || defaultToken;\n        const modelId = runtimeOptions.modelId || defaultModelId;\n\n        if (!token) {\n          throw new Error(\"Token is required\");\n        }\n        if (!modelId) {\n          throw new Error(\"Model ID is required\");\n        }\n\n        // Determine mode: microphone or manual\n        const microphone = runtimeOptions.microphone || defaultMicrophone;\n        const audioFormat = runtimeOptions.audioFormat || defaultAudioFormat;\n        const sampleRate = runtimeOptions.sampleRate || defaultSampleRate;\n\n        let connection: RealtimeConnection;\n\n        // Include timestamps if explicitly requested OR if the callback is provided\n        const includeTimestamps =\n          runtimeOptions.includeTimestamps ??\n          defaultIncludeTimestamps ??\n          !!(\n            runtimeOptions.onCommittedTranscriptWithTimestamps ||\n            onCommittedTranscriptWithTimestamps\n          );\n\n        if (microphone) {\n          // Microphone mode\n          connection = Scribe.connect({\n            token,\n            modelId,\n            baseUri: runtimeOptions.baseUri || defaultBaseUri,\n            commitStrategy:\n              runtimeOptions.commitStrategy || defaultCommitStrategy,\n            vadSilenceThresholdSecs:\n              runtimeOptions.vadSilenceThresholdSecs ||\n              defaultVadSilenceThresholdSecs,\n            vadThreshold: runtimeOptions.vadThreshold || defaultVadThreshold,\n            minSpeechDurationMs:\n              runtimeOptions.minSpeechDurationMs || defaultMinSpeechDurationMs,\n            minSilenceDurationMs:\n              runtimeOptions.minSilenceDurationMs ||\n              defaultMinSilenceDurationMs,\n            languageCode: runtimeOptions.languageCode || defaultLanguageCode,\n            microphone,\n            includeTimestamps,\n          } as MicrophoneOptions);\n        } else if (audioFormat && sampleRate) {\n          // Manual audio mode\n          connection = Scribe.connect({\n            token,\n            modelId,\n            baseUri: runtimeOptions.baseUri || defaultBaseUri,\n            commitStrategy:\n              runtimeOptions.commitStrategy || defaultCommitStrategy,\n            vadSilenceThresholdSecs:\n              runtimeOptions.vadSilenceThresholdSecs ||\n              defaultVadSilenceThresholdSecs,\n            vadThreshold: runtimeOptions.vadThreshold || defaultVadThreshold,\n            minSpeechDurationMs:\n              runtimeOptions.minSpeechDurationMs || defaultMinSpeechDurationMs,\n            minSilenceDurationMs:\n              runtimeOptions.minSilenceDurationMs ||\n              defaultMinSilenceDurationMs,\n            languageCode: runtimeOptions.languageCode || defaultLanguageCode,\n            includeTimestamps,\n            audioFormat,\n            sampleRate,\n          } as AudioOptions);\n        } else {\n          throw new Error(\n            \"Either microphone options or (audioFormat + sampleRate) must be provided\"\n          );\n        }\n\n        connectionRef.current = connection;\n\n        // Set up event listeners\n        connection.on(RealtimeEvents.SESSION_STARTED, () => {\n          setStatus(\"connected\");\n          onSessionStarted?.();\n        });\n\n        connection.on(RealtimeEvents.PARTIAL_TRANSCRIPT, (data: unknown) => {\n          const message = data as PartialTranscriptMessage;\n          setPartialTranscript(message.text);\n          setStatus(\"transcribing\");\n          onPartialTranscript?.(message);\n        });\n\n        connection.on(RealtimeEvents.COMMITTED_TRANSCRIPT, (data: unknown) => {\n          const message = data as CommittedTranscriptMessage;\n          const segment: TranscriptSegment = {\n            id: `${Date.now()}-${Math.random()}`,\n            text: message.text,\n            timestamp: Date.now(),\n            isFinal: true,\n          };\n          setCommittedTranscripts(prev => [...prev, segment]);\n          setPartialTranscript(\"\");\n          onCommittedTranscript?.(message);\n        });\n\n        connection.on(\n          RealtimeEvents.COMMITTED_TRANSCRIPT_WITH_TIMESTAMPS,\n          (data: unknown) => {\n            const message = data as CommittedTranscriptWithTimestampsMessage;\n            const segment: TranscriptSegment = {\n              id: `${Date.now()}-${Math.random()}`,\n              text: message.text,\n              timestamp: Date.now(),\n              isFinal: true,\n              words: message.words,\n            };\n            setCommittedTranscripts(prev => [...prev, segment]);\n            setPartialTranscript(\"\");\n            onCommittedTranscriptWithTimestamps?.(message);\n          }\n        );\n\n        connection.on(RealtimeEvents.ERROR, (err: unknown) => {\n          const message = err as ScribeErrorMessage;\n          setError(message.error);\n          setStatus(\"error\");\n          onError?.(new Error(message.error));\n        });\n\n        connection.on(RealtimeEvents.AUTH_ERROR, (data: unknown) => {\n          const message = data as ScribeAuthErrorMessage;\n          setError(message.error);\n          setStatus(\"error\");\n          onAuthError?.(message);\n        });\n\n        connection.on(RealtimeEvents.QUOTA_EXCEEDED, (data: unknown) => {\n          const message = data as ScribeQuotaExceededErrorMessage;\n          setError(message.error);\n          setStatus(\"error\");\n          onQuotaExceededError?.(message);\n        });\n\n        connection.on(RealtimeEvents.COMMIT_THROTTLED, (data: unknown) => {\n          const message = data as ScribeCommitThrottledErrorMessage;\n          setError(message.error);\n          setStatus(\"error\");\n          onCommitThrottledError?.(message);\n        });\n\n        connection.on(RealtimeEvents.TRANSCRIBER_ERROR, (data: unknown) => {\n          const message = data as ScribeTranscriberErrorMessage;\n          setError(message.error);\n          setStatus(\"error\");\n          onTranscriberError?.(message);\n        });\n\n        connection.on(RealtimeEvents.UNACCEPTED_TERMS, (data: unknown) => {\n          const message = data as ScribeUnacceptedTermsErrorMessage;\n          setError(message.error);\n          setStatus(\"error\");\n          onUnacceptedTermsError?.(message);\n        });\n\n        connection.on(RealtimeEvents.RATE_LIMITED, (data: unknown) => {\n          const message = data as ScribeRateLimitedErrorMessage;\n          setError(message.error);\n          setStatus(\"error\");\n          onRateLimitedError?.(message);\n        });\n\n        connection.on(RealtimeEvents.INPUT_ERROR, (data: unknown) => {\n          const message = data as ScribeInputErrorMessage;\n          setError(message.error);\n          setStatus(\"error\");\n          onInputError?.(message);\n        });\n\n        connection.on(RealtimeEvents.QUEUE_OVERFLOW, (data: unknown) => {\n          const message = data as ScribeQueueOverflowErrorMessage;\n          setError(message.error);\n          setStatus(\"error\");\n          onQueueOverflowError?.(message);\n        });\n\n        connection.on(RealtimeEvents.RESOURCE_EXHAUSTED, (data: unknown) => {\n          const message = data as ScribeResourceExhaustedErrorMessage;\n          setError(message.error);\n          setStatus(\"error\");\n          onResourceExhaustedError?.(message);\n        });\n\n        connection.on(\n          RealtimeEvents.SESSION_TIME_LIMIT_EXCEEDED,\n          (data: unknown) => {\n            const message = data as ScribeSessionTimeLimitExceededErrorMessage;\n            setError(message.error);\n            setStatus(\"error\");\n            onSessionTimeLimitExceededError?.(message);\n          }\n        );\n\n        connection.on(RealtimeEvents.CHUNK_SIZE_EXCEEDED, (data: unknown) => {\n          const message = data as ScribeChunkSizeExceededErrorMessage;\n          setError(message.error);\n          setStatus(\"error\");\n          onChunkSizeExceededError?.(message);\n        });\n\n        connection.on(\n          RealtimeEvents.INSUFFICIENT_AUDIO_ACTIVITY,\n          (data: unknown) => {\n            const message = data as ScribeInsufficientAudioActivityErrorMessage;\n            setError(message.error);\n            setStatus(\"error\");\n            onInsufficientAudioActivityError?.(message);\n          }\n        );\n\n        connection.on(RealtimeEvents.OPEN, () => {\n          onConnect?.();\n        });\n\n        connection.on(RealtimeEvents.CLOSE, () => {\n          setStatus(\"disconnected\");\n          connectionRef.current = null;\n          onDisconnect?.();\n        });\n      } catch (err) {\n        const errorMessage =\n          err instanceof Error ? err.message : \"Failed to connect\";\n        setError(errorMessage);\n        setStatus(\"error\");\n        throw err;\n      }\n    },\n    [\n      defaultToken,\n      defaultModelId,\n      defaultBaseUri,\n      defaultCommitStrategy,\n      defaultVadSilenceThresholdSecs,\n      defaultVadThreshold,\n      defaultMinSpeechDurationMs,\n      defaultMinSilenceDurationMs,\n      defaultLanguageCode,\n      defaultMicrophone,\n      defaultAudioFormat,\n      defaultSampleRate,\n      defaultIncludeTimestamps,\n      onSessionStarted,\n      onPartialTranscript,\n      onCommittedTranscript,\n      onCommittedTranscriptWithTimestamps,\n      onError,\n      onAuthError,\n      onQuotaExceededError,\n      onCommitThrottledError,\n      onTranscriberError,\n      onUnacceptedTermsError,\n      onRateLimitedError,\n      onInputError,\n      onQueueOverflowError,\n      onResourceExhaustedError,\n      onSessionTimeLimitExceededError,\n      onChunkSizeExceededError,\n      onInsufficientAudioActivityError,\n      onConnect,\n      onDisconnect,\n    ]\n  );\n\n  const disconnect = useCallback(() => {\n    connectionRef.current?.close();\n    connectionRef.current = null;\n    setStatus(\"disconnected\");\n  }, []);\n\n  const sendAudio = useCallback(\n    (\n      audioBase64: string,\n      options?: { commit?: boolean; sampleRate?: number; previousText?: string }\n    ) => {\n      if (!connectionRef.current) {\n        throw new Error(\"Not connected to Scribe\");\n      }\n      connectionRef.current.send({ audioBase64, ...options });\n    },\n    []\n  );\n\n  const commit = useCallback(() => {\n    if (!connectionRef.current) {\n      throw new Error(\"Not connected to Scribe\");\n    }\n    connectionRef.current.commit();\n  }, []);\n\n  const clearTranscripts = useCallback(() => {\n    setCommittedTranscripts([]);\n    setPartialTranscript(\"\");\n  }, []);\n\n  const getConnection = useCallback(() => {\n    return connectionRef.current;\n  }, []);\n\n  // Auto-connect if enabled\n  useEffect(() => {\n    if (autoConnect) {\n      connect();\n    }\n  }, [autoConnect, connect]);\n\n  return {\n    // State\n    status,\n    isConnected: status === \"connected\" || status === \"transcribing\",\n    isTranscribing: status === \"transcribing\",\n    partialTranscript,\n    committedTranscripts,\n    error,\n\n    // Methods\n    connect,\n    disconnect,\n    sendAudio,\n    commit,\n    clearTranscripts,\n    getConnection,\n  };\n}\n\n// Export types and enums from client for convenience\nexport {\n  AudioFormat,\n  CommitStrategy,\n  RealtimeEvents,\n} from \"@elevenlabs/client\";\nexport type { RealtimeConnection } from \"@elevenlabs/client\";\n","import { useEffect, useRef, useState } from \"react\";\nimport {\n  Conversation,\n  type SessionConfig,\n  type Options,\n  type ClientToolsConfig,\n  type InputConfig,\n  type AudioWorkletConfig,\n  type OutputConfig,\n  type FormatConfig,\n  type Mode,\n  type Status,\n  type Callbacks,\n} from \"@elevenlabs/client\";\n\n// Device configuration types for audio device switching\nexport type DeviceFormatConfig = {\n  format: \"pcm\" | \"ulaw\";\n  sampleRate: number;\n  outputDeviceId?: string;\n};\n\nexport type DeviceInputConfig = {\n  preferHeadphonesForIosDevices?: boolean;\n  inputDeviceId?: string;\n};\n\nimport { PACKAGE_VERSION } from \"./version\";\n\nexport type Location = \"us\" | \"global\" | \"eu-residency\" | \"in-residency\";\n\nexport function parseLocation(location: string = \"us\"): Location {\n  switch (location) {\n    case \"eu-residency\":\n    case \"in-residency\":\n    case \"us\":\n    case \"global\":\n      return location;\n    default:\n      console.warn(\n        `[ConversationalAI] Invalid server-location: ${location}. Defaulting to \"us\"`\n      );\n      return \"us\";\n  }\n}\n\nexport function getOriginForLocation(location: Location): string {\n  const originMap: Record<Location, string> = {\n    us: \"wss://api.elevenlabs.io\",\n    \"eu-residency\": \"wss://api.eu.residency.elevenlabs.io\",\n    \"in-residency\": \"wss://api.in.residency.elevenlabs.io\",\n    global: \"wss://api.elevenlabs.io\",\n  };\n\n  return originMap[location];\n}\n\nexport function getLivekitUrlForLocation(location: Location): string {\n  const livekitUrlMap: Record<Location, string> = {\n    us: \"wss://livekit.rtc.elevenlabs.io\",\n    \"eu-residency\": \"wss://livekit.rtc.eu.residency.elevenlabs.io\",\n    \"in-residency\": \"wss://livekit.rtc.in.residency.elevenlabs.io\",\n    global: \"wss://livekit.rtc.elevenlabs.io\",\n  };\n\n  return livekitUrlMap[location];\n}\n\nexport type {\n  Role,\n  Mode,\n  Status,\n  SessionConfig,\n  DisconnectionDetails,\n  Language,\n  VadScoreEvent,\n  InputConfig,\n  FormatConfig,\n  VoiceConversation,\n  TextConversation,\n  Callbacks,\n} from \"@elevenlabs/client\";\nexport { postOverallFeedback } from \"@elevenlabs/client\";\n\n// Scribe exports\nexport {\n  useScribe,\n  AudioFormat,\n  CommitStrategy,\n  RealtimeEvents,\n} from \"./scribe\";\nexport type {\n  ScribeStatus,\n  TranscriptSegment,\n  WordTimestamp,\n  ScribeCallbacks,\n  ScribeHookOptions,\n  UseScribeReturn,\n  RealtimeConnection,\n} from \"./scribe\";\n\nexport type HookOptions = Partial<\n  SessionConfig &\n    HookCallbacks &\n    ClientToolsConfig &\n    InputConfig &\n    OutputConfig &\n    AudioWorkletConfig &\n    FormatConfig & {\n      serverLocation?: Location | string;\n    }\n>;\nexport type ControlledState = {\n  micMuted?: boolean;\n  volume?: number;\n};\nexport type HookCallbacks = Pick<\n  Callbacks,\n  | \"onConnect\"\n  | \"onDisconnect\"\n  | \"onError\"\n  | \"onMessage\"\n  | \"onAudio\"\n  | \"onModeChange\"\n  | \"onStatusChange\"\n  | \"onCanSendFeedbackChange\"\n  | \"onDebug\"\n  | \"onUnhandledClientToolCall\"\n  | \"onVadScore\"\n  | \"onInterruption\"\n  | \"onAgentToolResponse\"\n  | \"onAgentToolRequest\"\n  | \"onConversationMetadata\"\n  | \"onMCPToolCall\"\n  | \"onMCPConnectionStatus\"\n  | \"onAsrInitiationMetadata\"\n  | \"onAgentChatResponsePart\"\n>;\n\nexport function useConversation<T extends HookOptions & ControlledState>(\n  props: T = {} as T\n) {\n  const { micMuted, volume, serverLocation, ...defaultOptions } = props;\n  const conversationRef = useRef<Conversation | null>(null);\n  const lockRef = useRef<Promise<Conversation> | null>(null);\n  const [status, setStatus] = useState<Status>(\"disconnected\");\n  const [canSendFeedback, setCanSendFeedback] = useState(false);\n  const [mode, setMode] = useState<Mode>(\"listening\");\n\n  const micMutedRef = useRef<boolean | undefined>(micMuted);\n  const volumeRef = useRef<number | undefined>(volume);\n\n  micMutedRef.current = micMuted;\n  volumeRef.current = volume;\n\n  useEffect(() => {\n    if (micMuted !== undefined) {\n      conversationRef?.current?.setMicMuted(micMuted);\n    }\n  }, [micMuted]);\n\n  useEffect(() => {\n    if (volume !== undefined) {\n      conversationRef?.current?.setVolume({ volume });\n    }\n  }, [volume]);\n\n  useEffect(() => {\n    return () => {\n      conversationRef.current?.endSession();\n    };\n  }, []);\n\n  return {\n    startSession: (async (options?: HookOptions) => {\n      if (conversationRef.current?.isOpen()) {\n        return conversationRef.current.getId();\n      }\n\n      if (lockRef.current) {\n        const conversation = await lockRef.current;\n        return conversation.getId();\n      }\n\n      try {\n        const resolvedServerLocation = parseLocation(\n          options?.serverLocation || serverLocation\n        );\n        const origin = getOriginForLocation(resolvedServerLocation);\n        const calculatedLivekitUrl = getLivekitUrlForLocation(\n          resolvedServerLocation\n        );\n\n        lockRef.current = Conversation.startSession({\n          ...(defaultOptions ?? {}),\n          ...(options ?? {}),\n          origin,\n\n          livekitUrl:\n            options?.livekitUrl ||\n            defaultOptions?.livekitUrl ||\n            calculatedLivekitUrl,\n          overrides: {\n            ...(defaultOptions?.overrides ?? {}),\n            ...(options?.overrides ?? {}),\n            client: {\n              ...(defaultOptions?.overrides?.client ?? {}),\n              ...(options?.overrides?.client ?? {}),\n              source:\n                options?.overrides?.client?.source ||\n                defaultOptions?.overrides?.client?.source ||\n                \"react_sdk\",\n              version:\n                options?.overrides?.client?.version ||\n                defaultOptions?.overrides?.client?.version ||\n                PACKAGE_VERSION,\n            },\n          },\n          // Pass through user-provided callbacks\n          onConnect: options?.onConnect || defaultOptions?.onConnect,\n          onDisconnect: options?.onDisconnect || defaultOptions?.onDisconnect,\n          onError: options?.onError || defaultOptions?.onError,\n          onMessage: options?.onMessage || defaultOptions?.onMessage,\n          onAudio: options?.onAudio || defaultOptions?.onAudio,\n          onDebug: options?.onDebug || defaultOptions?.onDebug,\n          onUnhandledClientToolCall:\n            options?.onUnhandledClientToolCall ||\n            defaultOptions?.onUnhandledClientToolCall,\n          onVadScore: options?.onVadScore || defaultOptions?.onVadScore,\n          onInterruption:\n            options?.onInterruption || defaultOptions?.onInterruption,\n          onAgentToolRequest:\n            options?.onAgentToolRequest || defaultOptions?.onAgentToolRequest,\n          onAgentToolResponse:\n            options?.onAgentToolResponse || defaultOptions?.onAgentToolResponse,\n          onConversationMetadata:\n            options?.onConversationMetadata ||\n            defaultOptions?.onConversationMetadata,\n          onMCPToolCall:\n            options?.onMCPToolCall || defaultOptions?.onMCPToolCall,\n          onMCPConnectionStatus:\n            options?.onMCPConnectionStatus ||\n            defaultOptions?.onMCPConnectionStatus,\n          onAsrInitiationMetadata:\n            options?.onAsrInitiationMetadata ||\n            defaultOptions?.onAsrInitiationMetadata,\n          onAgentChatResponsePart:\n            options?.onAgentChatResponsePart ||\n            defaultOptions?.onAgentChatResponsePart,\n          onModeChange: ({ mode }) => {\n            setMode(mode);\n            (options?.onModeChange || defaultOptions?.onModeChange)?.({ mode });\n          },\n          onStatusChange: ({ status }) => {\n            setStatus(status);\n            (options?.onStatusChange || defaultOptions?.onStatusChange)?.({\n              status,\n            });\n          },\n          onCanSendFeedbackChange: ({ canSendFeedback }) => {\n            setCanSendFeedback(canSendFeedback);\n            (\n              options?.onCanSendFeedbackChange ||\n              defaultOptions?.onCanSendFeedbackChange\n            )?.({ canSendFeedback });\n          },\n        } as Options);\n\n        conversationRef.current = await lockRef.current;\n        // Persist controlled state between sessions using refs to get current values\n        if (micMutedRef.current !== undefined) {\n          conversationRef.current.setMicMuted(micMutedRef.current);\n        }\n        if (volumeRef.current !== undefined) {\n          conversationRef.current.setVolume({ volume: volumeRef.current });\n        }\n\n        return conversationRef.current.getId();\n      } finally {\n        lockRef.current = null;\n      }\n    }) as T extends SessionConfig\n      ? (options?: HookOptions) => Promise<string>\n      : (options: SessionConfig & HookOptions) => Promise<string>,\n    endSession: async () => {\n      const conversation = conversationRef.current;\n      conversationRef.current = null;\n      await conversation?.endSession();\n    },\n    setVolume: ({ volume }: { volume: number }) => {\n      conversationRef.current?.setVolume({ volume });\n    },\n    getInputByteFrequencyData: () => {\n      return conversationRef.current?.getInputByteFrequencyData();\n    },\n    getOutputByteFrequencyData: () => {\n      return conversationRef.current?.getOutputByteFrequencyData();\n    },\n    getInputVolume: () => {\n      return conversationRef.current?.getInputVolume() ?? 0;\n    },\n    getOutputVolume: () => {\n      return conversationRef.current?.getOutputVolume() ?? 0;\n    },\n    sendFeedback: (like: boolean) => {\n      conversationRef.current?.sendFeedback(like);\n    },\n    getId: () => {\n      return conversationRef.current?.getId();\n    },\n    sendContextualUpdate: (text: string) => {\n      conversationRef.current?.sendContextualUpdate(text);\n    },\n    sendUserMessage: (text: string) => {\n      conversationRef.current?.sendUserMessage(text);\n    },\n    sendUserActivity: () => {\n      conversationRef.current?.sendUserActivity();\n    },\n    sendMCPToolApprovalResult: (toolCallId: string, isApproved: boolean) => {\n      conversationRef.current?.sendMCPToolApprovalResult(\n        toolCallId,\n        isApproved\n      );\n    },\n    changeInputDevice: async (\n      config: DeviceFormatConfig & DeviceInputConfig\n    ) => {\n      if (\n        conversationRef.current &&\n        \"changeInputDevice\" in conversationRef.current\n      ) {\n        return await (\n          conversationRef.current as unknown as {\n            changeInputDevice: (config: any) => Promise<any>;\n          }\n        ).changeInputDevice(config);\n      }\n      throw new Error(\n        \"Device switching is only available for voice conversations\"\n      );\n    },\n    changeOutputDevice: async (config: DeviceFormatConfig) => {\n      if (\n        conversationRef.current &&\n        \"changeOutputDevice\" in conversationRef.current\n      ) {\n        return await (\n          conversationRef.current as unknown as {\n            changeOutputDevice: (config: any) => Promise<any>;\n          }\n        ).changeOutputDevice(config);\n      }\n      throw new Error(\n        \"Device switching is only available for voice conversations\"\n      );\n    },\n    status,\n    canSendFeedback,\n    micMuted,\n    isSpeaking: mode === \"speaking\",\n  };\n}\n\n// const con = useConversation({agentId: \"\"})\n","// This file is auto-generated during build\nexport const PACKAGE_VERSION = \"0.12.1\";\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}